VALGRIND(1)                                 Release 3.15.0                                 VALGRIND(1)

NNAAMMEE
       valgrind - a suite of tools for debugging and profiling programs

SSYYNNOOPPSSIISS
       vvaallggrriinndd [_v_a_l_g_r_i_n_d_-_o_p_t_i_o_n_s] [yyoouurr--pprrooggrraamm] [_y_o_u_r_-_p_r_o_g_r_a_m_-_o_p_t_i_o_n_s]

DDEESSCCRRIIPPTTIIOONN
       VVaallggrriinndd is a flexible program for debugging and profiling Linux executables. It consists of a
       core, which provides a synthetic CPU in software, and a series of debugging and profiling
       tools. The architecture is modular, so that new tools can be created easily and without
       disturbing the existing structure.

       Some of the options described below work with all Valgrind tools, and some only work with a few
       or one. The section MEMCHECK OPTIONS and those below it describe tool-specific options.

       This manual page covers only basic usage and options. For more comprehensive information,
       please see the HTML documentation on your system: $INSTALL/share/doc/valgrind/html/index.html,
       or online: http://www.valgrind.org/docs/manual/index.html.

TTOOOOLL SSEELLEECCTTIIOONN OOPPTTIIOONNSS
       The single most important option.

       ----ttooooll==<<ttoooollnnaammee>> [[ddeeffaauulltt:: mmeemmcchheecckk]]
           Run the Valgrind tool called _t_o_o_l_n_a_m_e, e.g. memcheck, cachegrind, callgrind, helgrind, drd,
           massif, dhat, lackey, none, exp-sgcheck, exp-bbv, etc.

BBAASSIICC OOPPTTIIOONNSS
       These options work with all tools.

       --hh ----hheellpp
           Show help for all options, both for the core and for the selected tool. If the option is
           repeated it is equivalent to giving ----hheellpp--ddeebbuugg.

       ----hheellpp--ddeebbuugg
           Same as ----hheellpp, but also lists debugging options which usually are only of use to
           Valgrind's developers.

       ----vveerrssiioonn
           Show the version number of the Valgrind core. Tools can have their own version numbers.
           There is a scheme in place to ensure that tools only execute when the core version is one
           they are known to work with. This was done to minimise the chances of strange problems
           arising from tool-vs-core version incompatibilities.

       --qq, ----qquuiieett
           Run silently, and only print error messages. Useful if you are running regression tests or
           have some other automated test machinery.

       --vv, ----vveerrbboossee
           Be more verbose. Gives extra information on various aspects of your program, such as: the
           shared objects loaded, the suppressions used, the progress of the instrumentation and
           execution engines, and warnings about unusual behaviour. Repeating the option increases the
           verbosity level.

       ----ttrraaccee--cchhiillddrreenn==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           When enabled, Valgrind will trace into sub-processes initiated via the _e_x_e_c system call.
           This is necessary for multi-process programs.

           Note that Valgrind does trace into the child of a _f_o_r_k (it would be difficult not to, since
           _f_o_r_k makes an identical copy of a process), so this option is arguably badly named.
           However, most children of _f_o_r_k calls immediately call _e_x_e_c anyway.

       ----ttrraaccee--cchhiillddrreenn--sskkiipp==ppaatttt11,,ppaatttt22,,......
           This option only has an effect when ----ttrraaccee--cchhiillddrreenn==yyeess is specified. It allows for some
           children to be skipped. The option takes a comma separated list of patterns for the names
           of child executables that Valgrind should not trace into. Patterns may include the
           metacharacters ?  and *, which have the usual meaning.

           This can be useful for pruning uninteresting branches from a tree of processes being run on
           Valgrind. But you should be careful when using it. When Valgrind skips tracing into an
           executable, it doesn't just skip tracing that executable, it also skips tracing any of that
           executable's child processes. In other words, the flag doesn't merely cause tracing to stop
           at the specified executables -- it skips tracing of entire process subtrees rooted at any
           of the specified executables.

       ----ttrraaccee--cchhiillddrreenn--sskkiipp--bbyy--aarrgg==ppaatttt11,,ppaatttt22,,......
           This is the same as ----ttrraaccee--cchhiillddrreenn--sskkiipp, with one difference: the decision as to whether
           to trace into a child process is made by examining the arguments to the child process,
           rather than the name of its executable.

       ----cchhiilldd--ssiilleenntt--aafftteerr--ffoorrkk==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           When enabled, Valgrind will not show any debugging or logging output for the child process
           resulting from a _f_o_r_k call. This can make the output less confusing (although more
           misleading) when dealing with processes that create children. It is particularly useful in
           conjunction with _-_-_t_r_a_c_e_-_c_h_i_l_d_r_e_n_=. Use of this option is also strongly recommended if you
           are requesting XML output (_-_-_x_m_l_=_y_e_s), since otherwise the XML from child and parent may
           become mixed up, which usually makes it useless.

       ----vvggddbb==<<nnoo||yyeess||ffuullll>> [[ddeeffaauulltt:: yyeess]]
           Valgrind will provide "gdbserver" functionality when ----vvggddbb==yyeess or ----vvggddbb==ffuullll is
           specified. This allows an external GNU GDB debugger to control and debug your program when
           it runs on Valgrind.  ----vvggddbb==ffuullll incurs significant performance overheads, but provides
           more precise breakpoints and watchpoints. See Debugging your program using Valgrind's
           gdbserver and GDB for a detailed description.

           If the embedded gdbserver is enabled but no gdb is currently being used, the vgdb command
           line utility can send "monitor commands" to Valgrind from a shell. The Valgrind core
           provides a set of Valgrind monitor commands. A tool can optionally provide tool specific
           monitor commands, which are documented in the tool specific chapter.

       ----vvggddbb--eerrrroorr==<<nnuummbbeerr>> [[ddeeffaauulltt:: 999999999999999999]]
           Use this option when the Valgrind gdbserver is enabled with ----vvggddbb==yyeess or ----vvggddbb==ffuullll.
           Tools that report errors will wait for "number" errors to be reported before freezing the
           program and waiting for you to connect with GDB. It follows that a value of zero will cause
           the gdbserver to be started before your program is executed. This is typically used to
           insert GDB breakpoints before execution, and also works with tools that do not report
           errors, such as Massif.

       ----vvggddbb--ssttoopp--aatt==<<sseett>> [[ddeeffaauulltt:: nnoonnee]]
           Use this option when the Valgrind gdbserver is enabled with ----vvggddbb==yyeess or ----vvggddbb==ffuullll. The
           Valgrind gdbserver will be invoked for each error after ----vvggddbb--eerrrroorr have been reported.
           You can additionally ask the Valgrind gdbserver to be invoked for other events, specified
           in one of the following ways:

           •   a comma separated list of one or more of ssttaarrttuupp eexxiitt vvaallggrriinnddaabbeexxiitt.

               The values ssttaarrttuupp eexxiitt vvaallggrriinnddaabbeexxiitt respectively indicate to invoke gdbserver before
               your program is executed, after the last instruction of your program, on Valgrind
               abnormal exit (e.g. internal error, out of memory, ...).

               Note: ssttaarrttuupp and ----vvggddbb--eerrrroorr==00 will both cause Valgrind gdbserver to be invoked
               before your program is executed. The ----vvggddbb--eerrrroorr==00 will in addition cause your program
               to stop on all subsequent errors.

           •   aallll to specify the complete set. It is equivalent to
               ----vvggddbb--ssttoopp--aatt==ssttaarrttuupp,,eexxiitt,,vvaallggrriinnddaabbeexxiitt.

           •   nnoonnee for the empty set.

       ----ttrraacckk--ffddss==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           When enabled, Valgrind will print out a list of open file descriptors on exit or on
           request, via the gdbserver monitor command _v_._i_n_f_o _o_p_e_n___f_d_s. Along with each file descriptor
           is printed a stack backtrace of where the file was opened and any details relating to the
           file descriptor such as the file name or socket details.

       ----ttiimmee--ssttaammpp==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           When enabled, each message is preceded with an indication of the elapsed wallclock time
           since startup, expressed as days, hours, minutes, seconds and milliseconds.

       ----lloogg--ffdd==<<nnuummbbeerr>> [[ddeeffaauulltt:: 22,, ssttddeerrrr]]
           Specifies that Valgrind should send all of its messages to the specified file descriptor.
           The default, 2, is the standard error channel (stderr). Note that this may interfere with
           the client's own use of stderr, as Valgrind's output will be interleaved with any output
           that the client sends to stderr.

       ----lloogg--ffiillee==<<ffiilleennaammee>>
           Specifies that Valgrind should send all of its messages to the specified file. If the file
           name is empty, it causes an abort. There are three special format specifiers that can be
           used in the file name.

           %%pp is replaced with the current process ID. This is very useful for program that invoke
           multiple processes. WARNING: If you use ----ttrraaccee--cchhiillddrreenn==yyeess and your program invokes
           multiple processes OR your program forks without calling exec afterwards, and you don't use
           this specifier (or the %%qq specifier below), the Valgrind output from all those processes
           will go into one file, possibly jumbled up, and possibly incomplete. Note: If the program
           forks and calls exec afterwards, Valgrind output of the child from the period between fork
           and exec will be lost. Fortunately this gap is really tiny for most programs; and modern
           programs use posix_spawn anyway.

           %%nn is replaced with a file sequence number unique for this process. This is useful for
           processes that produces several files from the same filename template.

           %%qq{{FFOOOO}} is replaced with the contents of the environment variable _F_O_O. If the {{FFOOOO}} part is
           malformed, it causes an abort. This specifier is rarely needed, but very useful in certain
           circumstances (eg. when running MPI programs). The idea is that you specify a variable
           which will be set differently for each process in the job, for example BPROC_RANK or
           whatever is applicable in your MPI setup. If the named environment variable is not set, it
           causes an abort. Note that in some shells, the {{ and }} characters may need to be escaped
           with a backslash.

           %%%% is replaced with %%.

           If an %% is followed by any other character, it causes an abort.

           If the file name specifies a relative file name, it is put in the program's initial working
           directory: this is the current directory when the program started its execution after the
           fork or after the exec. If it specifies an absolute file name (ie. starts with '/') then it
           is put there.

       ----lloogg--ssoocckkeett==<<iipp--aaddddrreessss::ppoorrtt--nnuummbbeerr>>
           Specifies that Valgrind should send all of its messages to the specified port at the
           specified IP address. The port may be omitted, in which case port 1500 is used. If a
           connection cannot be made to the specified socket, Valgrind falls back to writing output to
           the standard error (stderr). This option is intended to be used in conjunction with the
           valgrind-listener program. For further details, see the commentary in the manual.

EERRRROORR--RREELLAATTEEDD OOPPTTIIOONNSS
       These options are used by all tools that can report errors, e.g. Memcheck, but not Cachegrind.

       ----xxmmll==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           When enabled, the important parts of the output (e.g. tool error messages) will be in XML
           format rather than plain text. Furthermore, the XML output will be sent to a different
           output channel than the plain text output. Therefore, you also must use one of ----xxmmll--ffdd,
           ----xxmmll--ffiillee or ----xxmmll--ssoocckkeett to specify where the XML is to be sent.

           Less important messages will still be printed in plain text, but because the XML output and
           plain text output are sent to different output channels (the destination of the plain text
           output is still controlled by ----lloogg--ffdd, ----lloogg--ffiillee and ----lloogg--ssoocckkeett) this should not cause
           problems.

           This option is aimed at making life easier for tools that consume Valgrind's output as
           input, such as GUI front ends. Currently this option works with Memcheck, Helgrind, DRD and
           SGcheck. The output format is specified in the file docs/internals/xml-output-protocol4.txt
           in the source tree for Valgrind 3.5.0 or later.

           The recommended options for a GUI to pass, when requesting XML output, are: ----xxmmll==yyeess to
           enable XML output, ----xxmmll--ffiillee to send the XML output to a (presumably GUI-selected) file,
           ----lloogg--ffiillee to send the plain text output to a second GUI-selected file,
           ----cchhiilldd--ssiilleenntt--aafftteerr--ffoorrkk==yyeess, and --qq to restrict the plain text output to critical error
           messages created by Valgrind itself. For example, failure to read a specified suppressions
           file counts as a critical error message. In this way, for a successful run the text output
           file will be empty. But if it isn't empty, then it will contain important information which
           the GUI user should be made aware of.

       ----xxmmll--ffdd==<<nnuummbbeerr>> [[ddeeffaauulltt:: --11,, ddiissaabblleedd]]
           Specifies that Valgrind should send its XML output to the specified file descriptor. It
           must be used in conjunction with ----xxmmll==yyeess.

       ----xxmmll--ffiillee==<<ffiilleennaammee>>
           Specifies that Valgrind should send its XML output to the specified file. It must be used
           in conjunction with ----xxmmll==yyeess. Any %%pp or %%qq sequences appearing in the filename are
           expanded in exactly the same way as they are for ----lloogg--ffiillee. See the description of --log-
           file for details.

       ----xxmmll--ssoocckkeett==<<iipp--aaddddrreessss::ppoorrtt--nnuummbbeerr>>
           Specifies that Valgrind should send its XML output the specified port at the specified IP
           address. It must be used in conjunction with ----xxmmll==yyeess. The form of the argument is the
           same as that used by ----lloogg--ssoocckkeett. See the description of ----lloogg--ssoocckkeett for further details.

       ----xxmmll--uusseerr--ccoommmmeenntt==<<ssttrriinngg>>
           Embeds an extra user comment string at the start of the XML output. Only works when
           ----xxmmll==yyeess is specified; ignored otherwise.

       ----ddeemmaannggllee==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           Enable/disable automatic demangling (decoding) of C++ names. Enabled by default. When
           enabled, Valgrind will attempt to translate encoded C++ names back to something approaching
           the original. The demangler handles symbols mangled by g++ versions 2.X, 3.X and 4.X.

           An important fact about demangling is that function names mentioned in suppressions files
           should be in their mangled form. Valgrind does not demangle function names when searching
           for applicable suppressions, because to do otherwise would make suppression file contents
           dependent on the state of Valgrind's demangling machinery, and also slow down suppression
           matching.

       ----nnuumm--ccaalllleerrss==<<nnuummbbeerr>> [[ddeeffaauulltt:: 1122]]
           Specifies the maximum number of entries shown in stack traces that identify program
           locations. Note that errors are commoned up using only the top four function locations (the
           place in the current function, and that of its three immediate callers). So this doesn't
           affect the total number of errors reported.

           The maximum value for this is 500. Note that higher settings will make Valgrind run a bit
           more slowly and take a bit more memory, but can be useful when working with programs with
           deeply-nested call chains.

       ----uunnww--ssttaacckk--ssccaann--tthhrreesshh==<<nnuummbbeerr>> [[ddeeffaauulltt:: 00]] , ----uunnww--ssttaacckk--ssccaann--ffrraammeess==<<nnuummbbeerr>> [[ddeeffaauulltt:: 55]]
           Stack-scanning support is available only on ARM targets.

           These flags enable and control stack unwinding by stack scanning. When the normal stack
           unwinding mechanisms -- usage of Dwarf CFI records, and frame-pointer following -- fail,
           stack scanning may be able to recover a stack trace.

           Note that stack scanning is an imprecise, heuristic mechanism that may give very misleading
           results, or none at all. It should be used only in emergencies, when normal unwinding
           fails, and it is important to nevertheless have stack traces.

           Stack scanning is a simple technique: the unwinder reads words from the stack, and tries to
           guess which of them might be return addresses, by checking to see if they point just after
           ARM or Thumb call instructions. If so, the word is added to the backtrace.

           The main danger occurs when a function call returns, leaving its return address exposed,
           and a new function is called, but the new function does not overwrite the old address. The
           result of this is that the backtrace may contain entries for functions which have already
           returned, and so be very confusing.

           A second limitation of this implementation is that it will scan only the page (4KB,
           normally) containing the starting stack pointer. If the stack frames are large, this may
           result in only a few (or not even any) being present in the trace. Also, if you are unlucky
           and have an initial stack pointer near the end of its containing page, the scan may miss
           all interesting frames.

           By default stack scanning is disabled. The normal use case is to ask for it when a stack
           trace would otherwise be very short. So, to enable it, use --unw-stack-scan-thresh=number.
           This requests Valgrind to try using stack scanning to "extend" stack traces which contain
           fewer than number frames.

           If stack scanning does take place, it will only generate at most the number of frames
           specified by --unw-stack-scan-frames. Typically, stack scanning generates so many garbage
           entries that this value is set to a low value (5) by default. In no case will a stack trace
           larger than the value specified by --num-callers be created.

       ----eerrrroorr--lliimmiitt==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           When enabled, Valgrind stops reporting errors after 10,000,000 in total, or 1,000 different
           ones, have been seen. This is to stop the error tracking machinery from becoming a huge
           performance overhead in programs with many errors.

       ----eerrrroorr--eexxiittccooddee==<<nnuummbbeerr>> [[ddeeffaauulltt:: 00]]
           Specifies an alternative exit code to return if Valgrind reported any errors in the run.
           When set to the default value (zero), the return value from Valgrind will always be the
           return value of the process being simulated. When set to a nonzero value, that value is
           returned instead, if Valgrind detects any errors. This is useful for using Valgrind as part
           of an automated test suite, since it makes it easy to detect test cases for which Valgrind
           has reported errors, just by inspecting return codes.

       ----eexxiitt--oonn--ffiirrsstt--eerrrroorr==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           If this option is enabled, Valgrind exits on the first error. A nonzero exit value must be
           defined using --error-exitcode option. Useful if you are running regression tests or have
           some other automated test machinery.

       ----eerrrroorr--mmaarrkkeerrss==<<bbeeggiinn>>,,<<eenndd>> [[ddeeffaauulltt:: nnoonnee]]
           When errors are output as plain text (i.e. XML not used), ----eerrrroorr--mmaarrkkeerrss instructs to
           output a line containing the bbeeggiinn (eenndd) string before (after) each error.

           Such marker lines facilitate searching for errors and/or extracting errors in an output
           file that contain valgrind errors mixed with the program output.

           Note that empty markers are accepted. So, only using a begin (or an end) marker is
           possible.

       ----sshhooww--eerrrroorr--lliisstt==nnoo||yyeess [[ddeeffaauulltt:: nnoo]]
           If this option is enabled, for tools that report errors, valgrind will show the list of
           detected errors and the list of used suppressions at exit.

           Note that at verbosity 2 and above, valgrind automatically shows the list of detected
           errors and the list of used suppressions at exit, unless ----sshhooww--eerrrroorr--lliisstt==nnoo is selected.

       --ss
           Specifying --ss is equivalent to ----sshhooww--eerrrroorr--lliisstt==yyeess.

       ----ssiiggiillll--ddiiaaggnnoossttiiccss==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           Enable/disable printing of illegal instruction diagnostics. Enabled by default, but
           defaults to disabled when ----qquuiieett is given. The default can always be explicitly overridden
           by giving this option.

           When enabled, a warning message will be printed, along with some diagnostics, whenever an
           instruction is encountered that Valgrind cannot decode or translate, before the program is
           given a SIGILL signal. Often an illegal instruction indicates a bug in the program or
           missing support for the particular instruction in Valgrind. But some programs do
           deliberately try to execute an instruction that might be missing and trap the SIGILL signal
           to detect processor features. Using this flag makes it possible to avoid the diagnostic
           output that you would otherwise get in such cases.

       ----kkeeeepp--ddeebbuuggiinnffoo==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           When enabled, keep ("archive") symbols and all other debuginfo for unloaded code. This
           allows saved stack traces to include file/line info for code that has been dlclose'd (or
           similar). Be careful with this, since it can lead to unbounded memory use for programs
           which repeatedly load and unload shared objects.

           Some tools and some functionalities have only limited support for archived debug info.
           Memcheck fully supports it. Generally, tools that report errors can use archived debug info
           to show the error stack traces. The known limitations are: Helgrind's past access stack
           trace of a race condition is does not use archived debug info. Massif (and more generally
           the xtree Massif output format) does not make use of archived debug info. Only Memcheck has
           been (somewhat) tested with ----kkeeeepp--ddeebbuuggiinnffoo==yyeess, so other tools may have unknown
           limitations.

       ----sshhooww--bbeellooww--mmaaiinn==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           By default, stack traces for errors do not show any functions that appear beneath mmaaiinn
           because most of the time it's uninteresting C library stuff and/or gobbledygook.
           Alternatively, if mmaaiinn is not present in the stack trace, stack traces will not show any
           functions below mmaaiinn-like functions such as glibc's ____lliibbcc__ssttaarrtt__mmaaiinn. Furthermore, if
           mmaaiinn-like functions are present in the trace, they are normalised as ((bbeellooww mmaaiinn)), in order
           to make the output more deterministic.

           If this option is enabled, all stack trace entries will be shown and mmaaiinn-like functions
           will not be normalised.

       ----ffuullllppaatthh--aafftteerr==<<ssttrriinngg>> [[ddeeffaauulltt:: ddoonn''tt sshhooww ssoouurrccee ppaatthhss]]
           By default Valgrind only shows the filenames in stack traces, but not full paths to source
           files. When using Valgrind in large projects where the sources reside in multiple different
           directories, this can be inconvenient.  ----ffuullllppaatthh--aafftteerr provides a flexible solution to
           this problem. When this option is present, the path to each source file is shown, with the
           following all-important caveat: if ssttrriinngg is found in the path, then the path up to and
           including ssttrriinngg is omitted, else the path is shown unmodified. Note that ssttrriinngg is not
           required to be a prefix of the path.

           For example, consider a file named /home/janedoe/blah/src/foo/bar/xyzzy.c. Specifying
           ----ffuullllppaatthh--aafftteerr==//hhoommee//jjaanneeddooee//bbllaahh//ssrrcc// will cause Valgrind to show the name as
           foo/bar/xyzzy.c.

           Because the string is not required to be a prefix, ----ffuullllppaatthh--aafftteerr==ssrrcc// will produce the
           same output. This is useful when the path contains arbitrary machine-generated characters.
           For example, the path /my/build/dir/C32A1B47/blah/src/foo/xyzzy can be pruned to foo/xyzzy
           using ----ffuullllppaatthh--aafftteerr==//bbllaahh//ssrrcc//.

           If you simply want to see the full path, just specify an empty string: ----ffuullllppaatthh--aafftteerr==.
           This isn't a special case, merely a logical consequence of the above rules.

           Finally, you can use ----ffuullllppaatthh--aafftteerr multiple times. Any appearance of it causes Valgrind
           to switch to producing full paths and applying the above filtering rule. Each produced path
           is compared against all the ----ffuullllppaatthh--aafftteerr-specified strings, in the order specified. The
           first string to match causes the path to be truncated as described above. If none match,
           the full path is shown. This facilitates chopping off prefixes when the sources are drawn
           from a number of unrelated directories.

       ----eexxttrraa--ddeebbuuggiinnffoo--ppaatthh==<<ppaatthh>> [[ddeeffaauulltt:: uunnddeeffiinneedd aanndd uunnuusseedd]]
           By default Valgrind searches in several well-known paths for debug objects, such as
           /usr/lib/debug/.

           However, there may be scenarios where you may wish to put debug objects at an arbitrary
           location, such as external storage when running Valgrind on a mobile device with limited
           local storage. Another example might be a situation where you do not have permission to
           install debug object packages on the system where you are running Valgrind.

           In these scenarios, you may provide an absolute path as an extra, final place for Valgrind
           to search for debug objects by specifying ----eexxttrraa--ddeebbuuggiinnffoo--ppaatthh==//ppaatthh//ttoo//ddeebbuugg//oobbjjeeccttss.
           The given path will be prepended to the absolute path name of the searched-for object. For
           example, if Valgrind is looking for the debuginfo for /w/x/y/zz.so and
           ----eexxttrraa--ddeebbuuggiinnffoo--ppaatthh==//aa//bb//cc is specified, it will look for a debug object at
           /a/b/c/w/x/y/zz.so.

           This flag should only be specified once. If it is specified multiple times, only the last
           instance is honoured.

       ----ddeebbuuggiinnffoo--sseerrvveerr==iippaaddddrr::ppoorrtt [[ddeeffaauulltt:: uunnddeeffiinneedd aanndd uunnuusseedd]]
           This is a new, experimental, feature introduced in version 3.9.0.

           In some scenarios it may be convenient to read debuginfo from objects stored on a different
           machine. With this flag, Valgrind will query a debuginfo server running on ipaddr and
           listening on port port, if it cannot find the debuginfo object in the local filesystem.

           The debuginfo server must accept TCP connections on port port. The debuginfo server is
           contained in the source file auxprogs/valgrind-di-server.c. It will only serve from the
           directory it is started in.  port defaults to 1500 in both client and server if not
           specified.

           If Valgrind looks for the debuginfo for /w/x/y/zz.so by using the debuginfo server, it will
           strip the pathname components and merely request zz.so on the server. That in turn will
           look only in its current working directory for a matching debuginfo object.

           The debuginfo data is transmitted in small fragments (8 KB) as requested by Valgrind. Each
           block is compressed using LZO to reduce transmission time. The implementation has been
           tuned for best performance over a single-stage 802.11g (WiFi) network link.

           Note that checks for matching primary vs debug objects, using GNU debuglink CRC scheme, are
           performed even when using the debuginfo server. To disable such checking, you need to also
           specify --allow-mismatched-debuginfo=yes.

           By default the Valgrind build system will build valgrind-di-server for the target platform,
           which is almost certainly not what you want. So far we have been unable to find out how to
           get automake/autoconf to build it for the build platform. If you want to use it, you will
           have to recompile it by hand using the command shown at the top of
           auxprogs/valgrind-di-server.c.

       ----aallllooww--mmiissmmaattcchheedd--ddeebbuuggiinnffoo==nnoo||yyeess [[nnoo]]
           When reading debuginfo from separate debuginfo objects, Valgrind will by default check that
           the main and debuginfo objects match, using the GNU debuglink mechanism. This guarantees
           that it does not read debuginfo from out of date debuginfo objects, and also ensures that
           Valgrind can't crash as a result of mismatches.

           This check can be overridden using --allow-mismatched-debuginfo=yes. This may be useful
           when the debuginfo and main objects have not been split in the proper way. Be careful when
           using this, though: it disables all consistency checking, and Valgrind has been observed to
           crash when the main and debuginfo objects don't match.

       ----ssuupppprreessssiioonnss==<<ffiilleennaammee>> [[ddeeffaauulltt:: $$PPRREEFFIIXX//lliibb//vvaallggrriinndd//ddeeffaauulltt..ssuupppp]]
           Specifies an extra file from which to read descriptions of errors to suppress. You may use
           up to 100 extra suppression files.

       ----ggeenn--ssuupppprreessssiioonnss==<<yyeess||nnoo||aallll>> [[ddeeffaauulltt:: nnoo]]
           When set to _y_e_s, Valgrind will pause after every error shown and print the line:

                   ---- Print suppression ? --- [Return/N/n/Y/y/C/c] ----

           Pressing _R_e_t, or _N _R_e_t or _n _R_e_t, causes Valgrind continue execution without printing a
           suppression for this error.

           Pressing _Y _R_e_t or _y _R_e_t causes Valgrind to write a suppression for this error. You can then
           cut and paste it into a suppression file if you don't want to hear about the error in the
           future.

           When set to _a_l_l, Valgrind will print a suppression for every reported error, without
           querying the user.

           This option is particularly useful with C++ programs, as it prints out the suppressions
           with mangled names, as required.

           Note that the suppressions printed are as specific as possible. You may want to common up
           similar ones, by adding wildcards to function names, and by using frame-level wildcards.
           The wildcarding facilities are powerful yet flexible, and with a bit of careful editing,
           you may be able to suppress a whole family of related errors with only a few suppressions.

           Sometimes two different errors are suppressed by the same suppression, in which case
           Valgrind will output the suppression more than once, but you only need to have one copy in
           your suppression file (but having more than one won't cause problems). Also, the
           suppression name is given as <insert a suppression name here>; the name doesn't really
           matter, it's only used with the --vv option which prints out all used suppression records.

       ----iinnppuutt--ffdd==<<nnuummbbeerr>> [[ddeeffaauulltt:: 00,, ssttddiinn]]
           When using ----ggeenn--ssuupppprreessssiioonnss==yyeess, Valgrind will stop so as to read keyboard input from you
           when each error occurs. By default it reads from the standard input (stdin), which is
           problematic for programs which close stdin. This option allows you to specify an
           alternative file descriptor from which to read input.

       ----ddssyymmuuttiill==nnoo||yyeess [[yyeess]]
           This option is only relevant when running Valgrind on Mac OS X.

           Mac OS X uses a deferred debug information (debuginfo) linking scheme. When object files
           containing debuginfo are linked into a .dylib or an executable, the debuginfo is not copied
           into the final file. Instead, the debuginfo must be linked manually by running dsymutil, a
           system-provided utility, on the executable or .dylib. The resulting combined debuginfo is
           placed in a directory alongside the executable or .dylib, but with the extension .dSYM.

           With ----ddssyymmuuttiill==nnoo, Valgrind will detect cases where the .dSYM directory is either missing,
           or is present but does not appear to match the associated executable or .dylib, most likely
           because it is out of date. In these cases, Valgrind will print a warning message but take
           no further action.

           With ----ddssyymmuuttiill==yyeess, Valgrind will, in such cases, automatically run dsymutil as necessary
           to bring the debuginfo up to date. For all practical purposes, if you always use
           ----ddssyymmuuttiill==yyeess, then there is never any need to run dsymutil manually or as part of your
           applications's build system, since Valgrind will run it as necessary.

           Valgrind will not attempt to run dsymutil on any executable or library in /usr/, /bin/,
           /sbin/, /opt/, /sw/, /System/, /Library/ or /Applications/ since dsymutil will always fail
           in such situations. It fails both because the debuginfo for such pre-installed system
           components is not available anywhere, and also because it would require write privileges in
           those directories.

           Be careful when using ----ddssyymmuuttiill==yyeess, since it will cause pre-existing .dSYM directories to
           be silently deleted and re-created. Also note that dsymutil is quite slow, sometimes
           excessively so.

       ----mmaaxx--ssttaacckkffrraammee==<<nnuummbbeerr>> [[ddeeffaauulltt:: 22000000000000]]
           The maximum size of a stack frame. If the stack pointer moves by more than this amount then
           Valgrind will assume that the program is switching to a different stack.

           You may need to use this option if your program has large stack-allocated arrays. Valgrind
           keeps track of your program's stack pointer. If it changes by more than the threshold
           amount, Valgrind assumes your program is switching to a different stack, and Memcheck
           behaves differently than it would for a stack pointer change smaller than the threshold.
           Usually this heuristic works well. However, if your program allocates large structures on
           the stack, this heuristic will be fooled, and Memcheck will subsequently report large
           numbers of invalid stack accesses. This option allows you to change the threshold to a
           different value.

           You should only consider use of this option if Valgrind's debug output directs you to do
           so. In that case it will tell you the new threshold you should specify.

           In general, allocating large structures on the stack is a bad idea, because you can easily
           run out of stack space, especially on systems with limited memory or which expect to
           support large numbers of threads each with a small stack, and also because the error
           checking performed by Memcheck is more effective for heap-allocated data than for
           stack-allocated data. If you have to use this option, you may wish to consider rewriting
           your code to allocate on the heap rather than on the stack.

       ----mmaaiinn--ssttaacckkssiizzee==<<nnuummbbeerr>> [[ddeeffaauulltt:: uussee ccuurrrreenntt ''uulliimmiitt'' vvaalluuee]]
           Specifies the size of the main thread's stack.

           To simplify its memory management, Valgrind reserves all required space for the main
           thread's stack at startup. That means it needs to know the required stack size at startup.

           By default, Valgrind uses the current "ulimit" value for the stack size, or 16 MB,
           whichever is lower. In many cases this gives a stack size in the range 8 to 16 MB, which
           almost never overflows for most applications.

           If you need a larger total stack size, use ----mmaaiinn--ssttaacckkssiizzee to specify it. Only set it as
           high as you need, since reserving far more space than you need (that is, hundreds of
           megabytes more than you need) constrains Valgrind's memory allocators and may reduce the
           total amount of memory that Valgrind can use. This is only really of significance on 32-bit
           machines.

           On Linux, you may request a stack of size up to 2GB. Valgrind will stop with a diagnostic
           message if the stack cannot be allocated.

           ----mmaaiinn--ssttaacckkssiizzee only affects the stack size for the program's initial thread. It has no
           bearing on the size of thread stacks, as Valgrind does not allocate those.

           You may need to use both ----mmaaiinn--ssttaacckkssiizzee and ----mmaaxx--ssttaacckkffrraammee together. It is important to
           understand that ----mmaaiinn--ssttaacckkssiizzee sets the maximum total stack size, whilst ----mmaaxx--ssttaacckkffrraammee
           specifies the largest size of any one stack frame. You will have to work out the
           ----mmaaiinn--ssttaacckkssiizzee value for yourself (usually, if your applications segfaults). But Valgrind
           will tell you the needed ----mmaaxx--ssttaacckkffrraammee size, if necessary.

           As discussed further in the description of ----mmaaxx--ssttaacckkffrraammee, a requirement for a large
           stack is a sign of potential portability problems. You are best advised to place all large
           data in heap-allocated memory.

       ----mmaaxx--tthhrreeaaddss==<<nnuummbbeerr>> [[ddeeffaauulltt:: 550000]]
           By default, Valgrind can handle to up to 500 threads. Occasionally, that number is too
           small. Use this option to provide a different limit. E.g.  --max-threads=3000.

MMAALLLLOOCC(())--RREELLAATTEEDD OOPPTTIIOONNSS
       For tools that use their own version of malloc (e.g. Memcheck, Massif, Helgrind, DRD), the
       following options apply.

       ----aalliiggnnmmeenntt==<<nnuummbbeerr>> [[ddeeffaauulltt:: 88 oorr 1166,, ddeeppeennddiinngg oonn tthhee ppllaattffoorrmm]]
           By default Valgrind's mmaalllloocc, rreeaalllloocc, etc, return a block whose starting address is 8-byte
           aligned or 16-byte aligned (the value depends on the platform and matches the platform
           default). This option allows you to specify a different alignment. The supplied value must
           be greater than or equal to the default, less than or equal to 4096, and must be a power of
           two.

       ----rreeddzzoonnee--ssiizzee==<<nnuummbbeerr>> [[ddeeffaauulltt:: ddeeppeennddss oonn tthhee ttooooll]]
           Valgrind's mmaalllloocc,, rreeaalllloocc,, etc, add padding blocks before and after each heap block
           allocated by the program being run. Such padding blocks are called redzones. The default
           value for the redzone size depends on the tool. For example, Memcheck adds and protects a
           minimum of 16 bytes before and after each block allocated by the client. This allows it to
           detect block underruns or overruns of up to 16 bytes.

           Increasing the redzone size makes it possible to detect overruns of larger distances, but
           increases the amount of memory used by Valgrind. Decreasing the redzone size will reduce
           the memory needed by Valgrind but also reduces the chances of detecting over/underruns, so
           is not recommended.

       ----xxttrreeee--mmeemmoorryy==nnoonnee||aallllooccss||ffuullll [[nnoonnee]]
           Tools replacing Valgrind's mmaalllloocc,, rreeaalllloocc,, etc, can optionally produce an execution tree
           detailing which piece of code is responsible for heap memory usage. See ???  for a detailed
           explanation about execution trees.

           When set to _n_o_n_e, no memory execution tree is produced.

           When set to _a_l_l_o_c_s, the memory execution tree gives the current number of allocated bytes
           and the current number of allocated blocks.

           When set to _f_u_l_l, the memory execution tree gives 6 different measurements : the current
           number of allocated bytes and blocks (same values as for _a_l_l_o_c_s), the total number of
           allocated bytes and blocks, the total number of freed bytes and blocks.

           Note that the overhead in cpu and memory to produce an xtree depends on the tool. The
           overhead in cpu is small for the value _a_l_l_o_c_s, as the information needed to produce this
           report is maintained in any case by the tool. For massif and helgrind, specifying _f_u_l_l
           implies to capture a stack trace for each free operation, while normally these tools only
           capture an allocation stack trace. For Memcheck, the cpu overhead for the value _f_u_l_l is
           small, as this can only be used in combination with ----kkeeeepp--ssttaacckkttrraacceess==aalllloocc--aanndd--ffrreeee or
           ----kkeeeepp--ssttaacckkttrraacceess==aalllloocc--tthheenn--ffrreeee, which already records a stack trace for each free
           operation. The memory overhead varies between 5 and 10 words per unique stacktrace in the
           xtree, plus the memory needed to record the stack trace for the free operations, if needed
           specifically for the xtree.

       ----xxttrreeee--mmeemmoorryy--ffiillee==<<ffiilleennaammee>> [[ddeeffaauulltt:: xxttmmeemmoorryy..kkccgg..%%pp]]
           Specifies that Valgrind should produce the xtree memory report in the specified file. Any
           %%pp or %%qq sequences appearing in the filename are expanded in exactly the same way as they
           are for ----lloogg--ffiillee. See the description of --log-file for details.

           If the filename contains the extension ..mmss, then the produced file format will be a massif
           output file format. If the filename contains the extension ..kkccgg or no extension is provided
           or recognised, then the produced file format will be a callgrind output format.

           See ???  for a detailed explanation about execution trees formats.

UUNNCCOOMMMMOONN OOPPTTIIOONNSS
       These options apply to all tools, as they affect certain obscure workings of the Valgrind core.
       Most people won't need to use them.

       ----ssmmcc--cchheecckk==<<nnoonnee||ssttaacckk||aallll||aallll--nnoonn--ffiillee>> [[ddeeffaauulltt:: aallll--nnoonn--ffiillee ffoorr xx8866//aammdd6644//ss339900xx,, ssttaacckk ffoorr
       ootthheerr aarrcchhss]]
           This option controls Valgrind's detection of self-modifying code. If no checking is done,
           when a program executes some code, then overwrites it with new code, and executes the new
           code, Valgrind will continue to execute the translations it made for the old code. This
           will likely lead to incorrect behaviour and/or crashes.

           For "modern" architectures -- anything that's not x86, amd64 or s390x -- the default is
           _s_t_a_c_k. This is because a correct program must take explicit action to reestablish D-I cache
           coherence following code modification. Valgrind observes and honours such actions, with the
           result that self-modifying code is transparently handled with zero extra cost.

           For x86, amd64 and s390x, the program is not required to notify the hardware of required
           D-I coherence syncing. Hence the default is _a_l_l_-_n_o_n_-_f_i_l_e, which covers the normal case of
           generating code into an anonymous (non-file-backed) mmap'd area.

           The meanings of the four available settings are as follows. No detection (_n_o_n_e), detect
           self-modifying code on the stack (which is used by GCC to implement nested functions)
           (_s_t_a_c_k), detect self-modifying code everywhere (_a_l_l), and detect self-modifying code
           everywhere except in file-backed mappings (_a_l_l_-_n_o_n_-_f_i_l_e).

           Running with _a_l_l will slow Valgrind down noticeably. Running with _n_o_n_e will rarely speed
           things up, since very little code gets dynamically generated in most programs. The
           VVAALLGGRRIINNDD__DDIISSCCAARRDD__TTRRAANNSSLLAATTIIOONNSS client request is an alternative to ----ssmmcc--cchheecckk==aallll and
           ----ssmmcc--cchheecckk==aallll--nnoonn--ffiillee that requires more programmer effort but allows Valgrind to run
           your program faster, by telling it precisely when translations need to be re-made.

           ----ssmmcc--cchheecckk==aallll--nnoonn--ffiillee provides a cheaper but more limited version of ----ssmmcc--cchheecckk==aallll. It
           adds checks to any translations that do not originate from file-backed memory mappings.
           Typical applications that generate code, for example JITs in web browsers, generate code
           into anonymous mmaped areas, whereas the "fixed" code of the browser always lives in
           file-backed mappings.  ----ssmmcc--cchheecckk==aallll--nnoonn--ffiillee takes advantage of this observation,
           limiting the overhead of checking to code which is likely to be JIT generated.

       ----rreeaadd--iinnlliinnee--iinnffoo==<<yyeess||nnoo>> [[ddeeffaauulltt:: sseeee bbeellooww]]
           When enabled, Valgrind will read information about inlined function calls from DWARF3 debug
           info. This slows Valgrind startup and makes it use more memory (typically for each inlined
           piece of code, 6 words and space for the function name), but it results in more descriptive
           stacktraces. Currently, this functionality is enabled by default only for Linux, Android
           and Solaris targets and only for the tools Memcheck, Massif, Helgrind and DRD. Here is an
           example of some stacktraces with ----rreeaadd--iinnlliinnee--iinnffoo==nnoo:

               ==15380== Conditional jump or move depends on uninitialised value(s)
               ==15380==    at 0x80484EA: main (inlinfo.c:6)
               ==15380==
               ==15380== Conditional jump or move depends on uninitialised value(s)
               ==15380==    at 0x8048550: fun_noninline (inlinfo.c:6)
               ==15380==    by 0x804850E: main (inlinfo.c:34)
               ==15380==
               ==15380== Conditional jump or move depends on uninitialised value(s)
               ==15380==    at 0x8048520: main (inlinfo.c:6)

           And here are the same errors with ----rreeaadd--iinnlliinnee--iinnffoo==yyeess:

               ==15377== Conditional jump or move depends on uninitialised value(s)
               ==15377==    at 0x80484EA: fun_d (inlinfo.c:6)
               ==15377==    by 0x80484EA: fun_c (inlinfo.c:14)
               ==15377==    by 0x80484EA: fun_b (inlinfo.c:20)
               ==15377==    by 0x80484EA: fun_a (inlinfo.c:26)
               ==15377==    by 0x80484EA: main (inlinfo.c:33)
               ==15377==
               ==15377== Conditional jump or move depends on uninitialised value(s)
               ==15377==    at 0x8048550: fun_d (inlinfo.c:6)
               ==15377==    by 0x8048550: fun_noninline (inlinfo.c:41)
               ==15377==    by 0x804850E: main (inlinfo.c:34)
               ==15377==
               ==15377== Conditional jump or move depends on uninitialised value(s)
               ==15377==    at 0x8048520: fun_d (inlinfo.c:6)
               ==15377==    by 0x8048520: main (inlinfo.c:35)

       ----rreeaadd--vvaarr--iinnffoo==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           When enabled, Valgrind will read information about variable types and locations from DWARF3
           debug info. This slows Valgrind startup significantly and makes it use significantly more
           memory, but for the tools that can take advantage of it (Memcheck, Helgrind, DRD) it can
           result in more precise error messages. For example, here are some standard errors issued by
           Memcheck:

               ==15363== Uninitialised byte(s) found during client check request
               ==15363==    at 0x80484A9: croak (varinfo1.c:28)
               ==15363==    by 0x8048544: main (varinfo1.c:55)
               ==15363==  Address 0x80497f7 is 7 bytes inside data symbol "global_i2"
               ==15363==
               ==15363== Uninitialised byte(s) found during client check request
               ==15363==    at 0x80484A9: croak (varinfo1.c:28)
               ==15363==    by 0x8048550: main (varinfo1.c:56)
               ==15363==  Address 0xbea0d0cc is on thread 1's stack
               ==15363==  in frame #1, created by main (varinfo1.c:45)

           And here are the same errors with ----rreeaadd--vvaarr--iinnffoo==yyeess:

               ==15370== Uninitialised byte(s) found during client check request
               ==15370==    at 0x80484A9: croak (varinfo1.c:28)
               ==15370==    by 0x8048544: main (varinfo1.c:55)
               ==15370==  Location 0x80497f7 is 0 bytes inside global_i2[7],
               ==15370==  a global variable declared at varinfo1.c:41
               ==15370==
               ==15370== Uninitialised byte(s) found during client check request
               ==15370==    at 0x80484A9: croak (varinfo1.c:28)
               ==15370==    by 0x8048550: main (varinfo1.c:56)
               ==15370==  Location 0xbeb4a0cc is 0 bytes inside local var "local"
               ==15370==  declared at varinfo1.c:46, in frame #1 of thread 1

       ----vvggddbb--ppoollll==<<nnuummbbeerr>> [[ddeeffaauulltt:: 55000000]]
           As part of its main loop, the Valgrind scheduler will poll to check if some activity (such
           as an external command or some input from a gdb) has to be handled by gdbserver. This
           activity poll will be done after having run the given number of basic blocks (or slightly
           more than the given number of basic blocks). This poll is quite cheap so the default value
           is set relatively low. You might further decrease this value if vgdb cannot use ptrace
           system call to interrupt Valgrind if all threads are (most of the time) blocked in a system
           call.

       ----vvggddbb--sshhaaddooww--rreeggiisstteerrss==nnoo||yyeess [[ddeeffaauulltt:: nnoo]]
           When activated, gdbserver will expose the Valgrind shadow registers to GDB. With this, the
           value of the Valgrind shadow registers can be examined or changed using GDB. Exposing
           shadow registers only works with GDB version 7.1 or later.

       ----vvggddbb--pprreeffiixx==<<pprreeffiixx>> [[ddeeffaauulltt:: //ttmmpp//vvggddbb--ppiippee]]
           To communicate with gdb/vgdb, the Valgrind gdbserver creates 3 files (2 named FIFOs and a
           mmap shared memory file). The prefix option controls the directory and prefix for the
           creation of these files.

       ----rruunn--lliibbcc--ffrreeeerreess==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           This option is only relevant when running Valgrind on Linux.

           The GNU C library (lliibbcc..ssoo), which is used by all programs, may allocate memory for its own
           uses. Usually it doesn't bother to free that memory when the program ends—there would be no
           point, since the Linux kernel reclaims all process resources when a process exits anyway,
           so it would just slow things down.

           The glibc authors realised that this behaviour causes leak checkers, such as Valgrind, to
           falsely report leaks in glibc, when a leak check is done at exit. In order to avoid this,
           they provided a routine called ____lliibbcc__ffrreeeerreess specifically to make glibc release all memory
           it has allocated. Memcheck therefore tries to run ____lliibbcc__ffrreeeerreess at exit.

           Unfortunately, in some very old versions of glibc, ____lliibbcc__ffrreeeerreess is sufficiently buggy to
           cause segmentation faults. This was particularly noticeable on Red Hat 7.1. So this option
           is provided in order to inhibit the run of ____lliibbcc__ffrreeeerreess. If your program seems to run
           fine on Valgrind, but segfaults at exit, you may find that ----rruunn--lliibbcc--ffrreeeerreess==nnoo fixes
           that, although at the cost of possibly falsely reporting space leaks in libc.so.

       ----rruunn--ccxxxx--ffrreeeerreess==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           This option is only relevant when running Valgrind on Linux or Solaris C++ programs.

           The GNU Standard C++ library (lliibbssttddcc++++..ssoo), which is used by all C++ programs compiled
           with g++, may allocate memory for its own uses. Usually it doesn't bother to free that
           memory when the program ends—there would be no point, since the kernel reclaims all process
           resources when a process exits anyway, so it would just slow things down.

           The gcc authors realised that this behaviour causes leak checkers, such as Valgrind, to
           falsely report leaks in libstdc++, when a leak check is done at exit. In order to avoid
           this, they provided a routine called ____ggnnuu__ccxxxx::::____ffrreeeerreess specifically to make libstdc++
           release all memory it has allocated. Memcheck therefore tries to run ____ggnnuu__ccxxxx::::____ffrreeeerreess
           at exit.

           For the sake of flexibility and unforeseen problems with ____ggnnuu__ccxxxx::::____ffrreeeerreess, option
           ----rruunn--ccxxxx--ffrreeeerreess==nnoo exists, although at the cost of possibly falsely reporting space leaks
           in libstdc++.so.

       ----ssiimm--hhiinnttss==hhiinntt11,,hhiinntt22,,......
           Pass miscellaneous hints to Valgrind which slightly modify the simulated behaviour in
           nonstandard or dangerous ways, possibly to help the simulation of strange features. By
           default no hints are enabled. Use with caution! Currently known hints are:

           •   llaaxx--iiooccttllss:: Be very lax about ioctl handling; the only assumption is that the size is
               correct. Doesn't require the full buffer to be initialised when writing. Without this,
               using some device drivers with a large number of strange ioctl commands becomes very
               tiresome.

           •   ffuussee--ccoommppaattiibbllee:: Enable special handling for certain system calls that may block in a
               FUSE file-system. This may be necessary when running Valgrind on a multi-threaded
               program that uses one thread to manage a FUSE file-system and another thread to access
               that file-system.

           •   eennaabbllee--oouutteerr:: Enable some special magic needed when the program being run is itself
               Valgrind.

           •   nnoo--iinnnneerr--pprreeffiixx:: Disable printing a prefix >> in front of each stdout or stderr output
               line in an inner Valgrind being run by an outer Valgrind. This is useful when running
               Valgrind regression tests in an outer/inner setup. Note that the prefix >> will always
               be printed in front of the inner debug logging lines.

           •   nnoo--nnppttll--pptthhrreeaadd--ssttaacckkccaacchhee:: This hint is only relevant when running Valgrind on Linux;
               it is ignored on Solaris and Mac OS X.

               The GNU glibc pthread library (lliibbpptthhrreeaadd..ssoo), which is used by pthread programs,
               maintains a cache of pthread stacks. When a pthread terminates, the memory used for the
               pthread stack and some thread local storage related data structure are not always
               directly released. This memory is kept in a cache (up to a certain size), and is
               re-used if a new thread is started.

               This cache causes the helgrind tool to report some false positive race condition errors
               on this cached memory, as helgrind does not understand the internal glibc cache
               synchronisation primitives. So, when using helgrind, disabling the cache helps to avoid
               false positive race conditions, in particular when using thread local storage variables
               (e.g. variables using the ____tthhrreeaadd qualifier).

               When using the memcheck tool, disabling the cache ensures the memory used by glibc to
               handle __thread variables is directly released when a thread terminates.

               Note: Valgrind disables the cache using some internal knowledge of the glibc stack
               cache implementation and by examining the debug information of the pthread library.
               This technique is thus somewhat fragile and might not work for all glibc versions. This
               has been successfully tested with various glibc versions (e.g. 2.11, 2.16, 2.18) on
               various platforms.

           •   llaaxx--ddoooorrss:: (Solaris only) Be very lax about door syscall handling over unrecognised
               door file descriptors. Does not require that full buffer is initialised when writing.
               Without this, programs using libdoor(3LIB) functionality with completely proprietary
               semantics may report large number of false positives.

           •   ffaallllbbaacckk--llllsscc:: (MIPS and ARM64 only): Enables an alternative implementation of
               Load-Linked (LL) and Store-Conditional (SC) instructions. The standard implementation
               gives more correct behaviour, but can cause indefinite looping on certain processor
               implementations that are intolerant of extra memory references between LL and SC. So
               far this is known only to happen on Cavium 3 cores. You should not need to use this
               flag, since the relevant cores are detected at startup and the alternative
               implementation is automatically enabled if necessary. There is no equivalent anti-flag:
               you cannot force-disable the alternative implementation, if it is automatically
               enabled. The underlying problem exists because the "standard" implementation of LL and
               SC is done by copying through LL and SC instructions into the instrumented code.
               However, tools may insert extra instrumentation memory references in between the LL and
               SC instructions. These memory references are not present in the original uninstrumented
               code, and their presence in the instrumented code can cause the SC instructions to
               persistently fail, leading to indefinite looping in LL-SC blocks. The alternative
               implementation gives correct behaviour of LL and SC instructions between threads in a
               process, up to and including the ABA scenario. It also gives correct behaviour between
               a Valgrinded thread and a non-Valgrinded thread running in a different process, that
               communicate via shared memory, but only up to and including correct CAS behaviour -- in
               this case the ABA scenario may not be correctly handled.

       ----ffaaiirr--sscchheedd==<<nnoo||yyeess||ttrryy>> [[ddeeffaauulltt:: nnoo]]
           The ----ffaaiirr--sscchheedd option controls the locking mechanism used by Valgrind to serialise thread
           execution. The locking mechanism controls the way the threads are scheduled, and different
           settings give different trade-offs between fairness and performance. For more details about
           the Valgrind thread serialisation scheme and its impact on performance and thread
           scheduling, see Scheduling and Multi-Thread Performance.

           •   The value ----ffaaiirr--sscchheedd==yyeess activates a fair scheduler. In short, if multiple threads
               are ready to run, the threads will be scheduled in a round robin fashion. This
               mechanism is not available on all platforms or Linux versions. If not available, using
               ----ffaaiirr--sscchheedd==yyeess will cause Valgrind to terminate with an error.

               You may find this setting improves overall responsiveness if you are running an
               interactive multithreaded program, for example a web browser, on Valgrind.

           •   The value ----ffaaiirr--sscchheedd==ttrryy activates fair scheduling if available on the platform.
               Otherwise, it will automatically fall back to ----ffaaiirr--sscchheedd==nnoo.

           •   The value ----ffaaiirr--sscchheedd==nnoo activates a scheduler which does not guarantee fairness
               between threads ready to run, but which in general gives the highest performance.

       ----kkeerrnneell--vvaarriiaanntt==vvaarriiaanntt11,,vvaarriiaanntt22,,......
           Handle system calls and ioctls arising from minor variants of the default kernel for this
           platform. This is useful for running on hacked kernels or with kernel modules which support
           nonstandard ioctls, for example. Use with caution. If you don't understand what this option
           does then you almost certainly don't need it. Currently known variants are:

           •   bbpprroocc: support the ssyyss__bbrroocc system call on x86. This is for running on BProc, which is
               a minor variant of standard Linux which is sometimes used for building clusters.

           •   aannddrrooiidd--nnoo--hhww--ttllss: some versions of the Android emulator for ARM do not provide a
               hardware TLS (thread-local state) register, and Valgrind crashes at startup. Use this
               variant to select software support for TLS.

           •   aannddrrooiidd--ggppuu--ssggxx55xxxx: use this to support handling of proprietary ioctls for the PowerVR
               SGX 5XX series of GPUs on Android devices. Failure to select this does not cause
               stability problems, but may cause Memcheck to report false errors after the program
               performs GPU-specific ioctls.

           •   aannddrrooiidd--ggppuu--aaddrreennoo33xxxx: similarly, use this to support handling of proprietary ioctls
               for the Qualcomm Adreno 3XX series of GPUs on Android devices.

       ----mmeerrggee--rreeccuurrssiivvee--ffrraammeess==<<nnuummbbeerr>> [[ddeeffaauulltt:: 00]]
           Some recursive algorithms, for example balanced binary tree implementations, create many
           different stack traces, each containing cycles of calls. A cycle is defined as two
           identical program counter values separated by zero or more other program counter values.
           Valgrind may then use a lot of memory to store all these stack traces. This is a poor use
           of memory considering that such stack traces contain repeated uninteresting recursive calls
           instead of more interesting information such as the function that has initiated the
           recursive call.

           The option ----mmeerrggee--rreeccuurrssiivvee--ffrraammeess==<<nnuummbbeerr>> instructs Valgrind to detect and merge
           recursive call cycles having a size of up to <<nnuummbbeerr>> frames. When such a cycle is
           detected, Valgrind records the cycle in the stack trace as a unique program counter.

           The value 0 (the default) causes no recursive call merging. A value of 1 will cause stack
           traces of simple recursive algorithms (for example, a factorial implementation) to be
           collapsed. A value of 2 will usually be needed to collapse stack traces produced by
           recursive algorithms such as binary trees, quick sort, etc. Higher values might be needed
           for more complex recursive algorithms.

           Note: recursive calls are detected by analysis of program counter values. They are not
           detected by looking at function names.

       ----nnuumm--ttrraannssttaabb--sseeccttoorrss==<<nnuummbbeerr>> [[ddeeffaauulltt:: 66 ffoorr AAnnddrrooiidd ppllaattffoorrmmss,, 1166 ffoorr aallll ootthheerrss]]
           Valgrind translates and instruments your program's machine code in small fragments (basic
           blocks). The translations are stored in a translation cache that is divided into a number
           of sections (sectors). If the cache is full, the sector containing the oldest translations
           is emptied and reused. If these old translations are needed again, Valgrind must
           re-translate and re-instrument the corresponding machine code, which is expensive. If the
           "executed instructions" working set of a program is big, increasing the number of sectors
           may improve performance by reducing the number of re-translations needed. Sectors are
           allocated on demand. Once allocated, a sector can never be freed, and occupies considerable
           space, depending on the tool and the value of ----aavvgg--ttrraannssttaabb--eennttrryy--ssiizzee (about 40 MB per
           sector for Memcheck). Use the option ----ssttaattss==yyeess to obtain precise information about the
           memory used by a sector and the allocation and recycling of sectors.

       ----aavvgg--ttrraannssttaabb--eennttrryy--ssiizzee==<<nnuummbbeerr>> [[ddeeffaauulltt:: 00,, mmeeaanniinngg uussee ttooooll pprroovviiddeedd ddeeffaauulltt]]
           Average size of translated basic block. This average size is used to dimension the size of
           a sector. Each tool provides a default value to be used. If this default value is too
           small, the translation sectors will become full too quickly. If this default value is too
           big, a significant part of the translation sector memory will be unused. Note that the
           average size of a basic block translation depends on the tool, and might depend on tool
           options. For example, the memcheck option ----ttrraacckk--oorriiggiinnss==yyeess increases the size of the
           basic block translations. Use ----aavvgg--ttrraannssttaabb--eennttrryy--ssiizzee to tune the size of the sectors,
           either to gain memory or to avoid too many retranslations.

       ----aassppaaccee--mmiinnaaddddrr==<<aaddddrreessss>> [[ddeeffaauulltt:: ddeeppeennddss oonn tthhee ppllaattffoorrmm]]
           To avoid potential conflicts with some system libraries, Valgrind does not use the address
           space below ----aassppaaccee--mmiinnaaddddrr value, keeping it reserved in case a library specifically
           requests memory in this region. So, some "pessimistic" value is guessed by Valgrind
           depending on the platform. On linux, by default, Valgrind avoids using the first 64MB even
           if typically there is no conflict in this complete zone. You can use the option
           ----aassppaaccee--mmiinnaaddddrr to have your memory hungry application benefitting from more of this lower
           memory. On the other hand, if you encounter a conflict, increasing aspace-minaddr value
           might solve it. Conflicts will typically manifest themselves with mmap failures in the low
           range of the address space. The provided address must be page aligned and must be equal or
           bigger to 0x1000 (4KB). To find the default value on your platform, do something such as
           valgrind -d -d date 2>&1 | grep -i minaddr. Values lower than 0x10000 (64KB) are known to
           create problems on some distributions.

       ----vvaallggrriinndd--ssttaacckkssiizzee==<<nnuummbbeerr>> [[ddeeffaauulltt:: 11MMBB]]
           For each thread, Valgrind needs its own 'private' stack. The default size for these stacks
           is largely dimensioned, and so should be sufficient in most cases. In case the size is too
           small, Valgrind will segfault. Before segfaulting, a warning might be produced by Valgrind
           when approaching the limit.

           Use the option ----vvaallggrriinndd--ssttaacckkssiizzee if such an (unlikely) warning is produced, or Valgrind
           dies due to a segmentation violation. Such segmentation violations have been seen when
           demangling huge C++ symbols.

           If your application uses many threads and needs a lot of memory, you can gain some memory
           by reducing the size of these Valgrind stacks using the option ----vvaallggrriinndd--ssttaacckkssiizzee.

       ----sshhooww--eemmwwaarrnnss==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           When enabled, Valgrind will emit warnings about its CPU emulation in certain cases. These
           are usually not interesting.

       ----rreeqquuiirree--tteexxtt--ssyymmbbooll==::ssoonnaammeeppaatttt::ffnnnnaammeeppaatttt
           When a shared object whose soname matches _s_o_n_a_m_e_p_a_t_t is loaded into the process, examine
           all the text symbols it exports. If none of those match _f_n_n_a_m_e_p_a_t_t, print an error message
           and abandon the run. This makes it possible to ensure that the run does not continue unless
           a given shared object contains a particular function name.

           Both _s_o_n_a_m_e_p_a_t_t and _f_n_n_a_m_e_p_a_t_t can be written using the usual _?  and _* wildcards. For
           example: _"_:_*_l_i_b_c_._s_o_*_:_f_o_o_?_b_a_r_". You may use characters other than a colon to separate the
           two patterns. It is only important that the first character and the separator character are
           the same. For example, the above example could also be written _"_Q_*_l_i_b_c_._s_o_*_Q_f_o_o_?_b_a_r_".
           Multiple
            _-_-_r_e_q_u_i_r_e_-_t_e_x_t_-_s_y_m_b_o_l flags are allowed, in which case shared objects that are loaded into
           the process will be checked against all of them.

           The purpose of this is to support reliable usage of marked-up libraries. For example,
           suppose we have a version of GCC's _l_i_b_g_o_m_p_._s_o which has been marked up with annotations to
           support Helgrind. It is only too easy and confusing to load the wrong, un-annotated
           _l_i_b_g_o_m_p_._s_o into the application. So the idea is: add a text symbol in the marked-up
           library, for example _a_n_n_o_t_a_t_e_d___f_o_r___h_e_l_g_r_i_n_d___3___6, and then give the flag
           _-_-_r_e_q_u_i_r_e_-_t_e_x_t_-_s_y_m_b_o_l_=_:_*_l_i_b_g_o_m_p_*_s_o_*_:_a_n_n_o_t_a_t_e_d___f_o_r___h_e_l_g_r_i_n_d___3___6 so that when _l_i_b_g_o_m_p_._s_o is
           loaded, Valgrind scans its symbol table, and if the symbol isn't present the run is
           aborted, rather than continuing silently with the un-marked-up library. Note that you
           should put the entire flag in quotes to stop shells expanding up the _* and _?  wildcards.

       ----ssoonnaammee--ssyynnoonnyymmss==ssyynn11==ppaatttteerrnn11,,ssyynn22==ppaatttteerrnn22,,......
           When a shared library is loaded, Valgrind checks for functions in the library that must be
           replaced or wrapped. For example, Memcheck replaces some string and memory functions
           (strchr, strlen, strcpy, memchr, memcpy, memmove, etc.) with its own versions. Such
           replacements are normally done only in shared libraries whose soname matches a predefined
           soname pattern (e.g.  _l_i_b_c_._s_o_* on linux). By default, no replacement is done for a
           statically linked binary or for alternative libraries, except for the allocation functions
           (malloc, free, calloc, memalign, realloc, operator new, operator delete, etc.) Such
           allocation functions are intercepted by default in any shared library or in the executable
           if they are exported as global symbols. This means that if a replacement allocation library
           such as tcmalloc is found, its functions are also intercepted by default. In some cases,
           the replacements allow ----ssoonnaammee--ssyynnoonnyymmss to specify one additional synonym pattern, giving
           flexibility in the replacement. Or to prevent interception of all public allocation
           symbols.

           Currently, this flexibility is only allowed for the malloc related functions, using the
           synonym _s_o_m_a_l_l_o_c. This synonym is usable for all tools doing standard replacement of malloc
           related functions (e.g. memcheck, helgrind, drd, massif, dhat, exp-sgcheck).

           •   Alternate malloc library: to replace the malloc related functions in a specific
               alternate library with soname _m_y_m_a_l_l_o_c_l_i_b_._s_o (and not in any others), give the option
               ----ssoonnaammee--ssyynnoonnyymmss==ssoommaalllloocc==mmyymmaalllloocclliibb..ssoo. A pattern can be used to match multiple
               libraries sonames. For example, ----ssoonnaammee--ssyynnoonnyymmss==ssoommaalllloocc==**ttccmmaalllloocc** will match the
               soname of all variants of the tcmalloc library (native, debug, profiled, ... tcmalloc
               variants).

               Note: the soname of a elf shared library can be retrieved using the readelf utility.

           •   Replacements in a statically linked library are done by using the _N_O_N_E pattern. For
               example, if you link with _l_i_b_t_c_m_a_l_l_o_c_._a, and only want to intercept the malloc related
               functions in the executable (and standard libraries) themselves, but not any other
               shared libraries, you can give the option ----ssoonnaammee--ssyynnoonnyymmss==ssoommaalllloocc==NNOONNEE. Note that a
               NONE pattern will match the main executable and any shared library having no soname.

           •   To run a "default" Firefox build for Linux, in which JEMalloc is linked in to the main
               executable, use ----ssoonnaammee--ssyynnoonnyymmss==ssoommaalllloocc==NNOONNEE.

           •   To only intercept allocation symbols in the default system libraries, but not in any
               other shared library or the executable defining public malloc or operator new related
               functions use a non-existing library name like
               ----ssoonnaammee--ssyynnoonnyymmss==ssoommaalllloocc==nnoouusseerriinntteerrcceeppttss (where _n_o_u_s_e_r_i_n_t_e_r_c_e_p_t_s can be any
               non-existing library name).

           •   Shared library of the dynamic (runtime) linker is excluded from searching for global
               public symbols, such as those for the malloc related functions (identified by _s_o_m_a_l_l_o_c
               synonym).

       ----pprrooggrreessss--iinntteerrvvaall==<<nnuummbbeerr>> [[ddeeffaauulltt:: 00,, mmeeaanniinngg ''ddiissaabblleedd'']]
           This is an enhancement to Valgrind's debugging output. It is unlikely to be of interest to
           end users.

           When _n_u_m_b_e_r is set to a non-zero value, Valgrind will print a one-line progress summary
           every _n_u_m_b_e_r seconds. Valid settings for _n_u_m_b_e_r are between 0 and 3600 inclusive. Here's
           some example output with _n_u_m_b_e_r set to 10:

               PROGRESS: U 110s, W 113s, 97.3% CPU, EvC 414.79M, TIn 616.7k, TOut 0.5k, #thr 67
               PROGRESS: U 120s, W 124s, 96.8% CPU, EvC 505.27M, TIn 636.6k, TOut 3.0k, #thr 64
               PROGRESS: U 130s, W 134s, 97.0% CPU, EvC 574.90M, TIn 657.5k, TOut 3.0k, #thr 63

           Each line shows:

           •   _U: total user time.RE

               •   _W: total wallclock time.RE

                   •   _C_P_U: overall average cpu use.RE

                       •   _E_v_C: number of event checks.  An event
                                    check is a backwards branch in the simulated program, so this is a
                                    measure of forward progress of the program.RE

                           •   _T_I_n: number of code blocks instrumented
                                         by the JIT.RE

                               •   _T_O_u_t: number of instrumented code
                                             blocks that have been thrown away.RE

                                   •   _#_t_h_r: number of threads in the
                                               program.RE

                                       From the progress of these, it is possible to observe:

                                       •   when the program is compute bound (_T_I_n
                                                     rises slowly, _E_v_C rises rapidly).RE

                                           •   when the program is in a spinloop
                                                         (_T_I_n/_T_O_u_t
                                                         fixed, _E_v_C rises rapidly).RE

                                               •   when the program is JIT-bound (_T_I_n
                                                             rises rapidly).RE

                                                   •   when the program is rapidly discarding code
                                                                 (_T_O_u_t rises rapidly).RE

                                                       •   when the program is about to achieve some
                                                           expected state
                                                                     (_E_v_C arrives at some value you
                                                                     expect).RE

                                                           •    when the program is idling (_U rises
                                                                         more slowly than _W).RE

DDEEBBUUGGGGIINNGG VVAALLGGRRIINNDD OOPPTTIIOONNSS
       There are also some options for debugging Valgrind itself. You shouldn't need to use them in
       the normal run of things. If you wish to see the list, use the ----hheellpp--ddeebbuugg option.

MMEEMMCCHHEECCKK OOPPTTIIOONNSS
       ----lleeaakk--cchheecckk==<<nnoo||ssuummmmaarryy||yyeess||ffuullll>> [[ddeeffaauulltt:: ssuummmmaarryy]]
           When enabled, search for memory leaks when the client program finishes. If set to _s_u_m_m_a_r_y,
           it says how many leaks occurred. If set to _f_u_l_l or _y_e_s, each individual leak will be shown
           in detail and/or counted as an error, as specified by the options ----sshhooww--lleeaakk--kkiinnddss and
           ----eerrrroorrss--ffoorr--lleeaakk--kkiinnddss.

       ----lleeaakk--rreessoolluuttiioonn==<<llooww||mmeedd||hhiigghh>> [[ddeeffaauulltt:: hhiigghh]]
           When doing leak checking, determines how willing Memcheck is to consider different
           backtraces to be the same for the purposes of merging multiple leaks into a single leak
           report. When set to _l_o_w, only the first two entries need match. When _m_e_d, four entries have
           to match. When _h_i_g_h, all entries need to match.

           For hardcore leak debugging, you probably want to use ----lleeaakk--rreessoolluuttiioonn==hhiigghh together with
           ----nnuumm--ccaalllleerrss==4400 or some such large number.

           Note that the ----lleeaakk--rreessoolluuttiioonn setting does not affect Memcheck's ability to find leaks.
           It only changes how the results are presented.

       ----sshhooww--lleeaakk--kkiinnddss==<<sseett>> [[ddeeffaauulltt:: ddeeffiinniittee,,ppoossssiibbllee]]
           Specifies the leak kinds to show in a _f_u_l_l leak search, in one of the following ways:

           •   a comma separated list of one or more of ddeeffiinniittee iinnddiirreecctt ppoossssiibbllee rreeaacchhaabbllee.

           •   aallll to specify the complete set (all leak kinds). It is equivalent to
               ----sshhooww--lleeaakk--kkiinnddss==ddeeffiinniittee,,iinnddiirreecctt,,ppoossssiibbllee,,rreeaacchhaabbllee.

           •   nnoonnee for the empty set.

       ----eerrrroorrss--ffoorr--lleeaakk--kkiinnddss==<<sseett>> [[ddeeffaauulltt:: ddeeffiinniittee,,ppoossssiibbllee]]
           Specifies the leak kinds to count as errors in a _f_u_l_l leak search. The <<sseett>> is specified
           similarly to ----sshhooww--lleeaakk--kkiinnddss

       ----lleeaakk--cchheecckk--hheeuurriissttiiccss==<<sseett>> [[ddeeffaauulltt:: aallll]]
           Specifies the set of leak check heuristics to be used during leak searches. The heuristics
           control which interior pointers to a block cause it to be considered as reachable. The
           heuristic set is specified in one of the following ways:

           •   a comma separated list of one or more of ssttddssttrriinngg lleennggtthh6644 nneewwaarrrraayy
               mmuullttiipplleeiinnhheerriittaannccee.

           •   aallll to activate the complete set of heuristics. It is equivalent to
               ----lleeaakk--cchheecckk--hheeuurriissttiiccss==ssttddssttrriinngg,,lleennggtthh6644,,nneewwaarrrraayy,,mmuullttiipplleeiinnhheerriittaannccee.

           •   nnoonnee for the empty set.

           Note that these heuristics are dependent on the layout of the objects produced by the C++
           compiler. They have been tested with some gcc versions (e.g. 4.4 and 4.7). They might not
           work properly with other C++ compilers.

       ----sshhooww--rreeaacchhaabbllee==<<yyeess||nnoo>> , ----sshhooww--ppoossssiibbllyy--lloosstt==<<yyeess||nnoo>>
           These options provide an alternative way to specify the leak kinds to show:

           •   ----sshhooww--rreeaacchhaabbllee==nnoo ----sshhooww--ppoossssiibbllyy--lloosstt==yyeess is equivalent to
               ----sshhooww--lleeaakk--kkiinnddss==ddeeffiinniittee,,ppoossssiibbllee.

           •   ----sshhooww--rreeaacchhaabbllee==nnoo ----sshhooww--ppoossssiibbllyy--lloosstt==nnoo is equivalent to
               ----sshhooww--lleeaakk--kkiinnddss==ddeeffiinniittee.

           •   ----sshhooww--rreeaacchhaabbllee==yyeess is equivalent to ----sshhooww--lleeaakk--kkiinnddss==aallll.

           Note that ----sshhooww--ppoossssiibbllyy--lloosstt==nnoo has no effect if ----sshhooww--rreeaacchhaabbllee==yyeess is specified.

       ----xxttrreeee--lleeaakk==<<nnoo||yyeess>> [[nnoo]]
           If set to yes, the results for the leak search done at exit will be output in a 'Callgrind
           Format' execution tree file. Note that this automatically sets the options
           ----lleeaakk--cchheecckk==ffuullll and ----sshhooww--lleeaakk--kkiinnddss==aallll, to allow xtree visualisation tools such as
           kcachegrind to select what kind to leak to visualise. The produced file will contain the
           following events:

           •   RRBB : Reachable Bytes

           •   PPBB : Possibly lost Bytes

           •   IIBB : Indirectly lost Bytes

           •   DDBB : Definitely lost Bytes (direct plus indirect)

           •   DDIIBB : Definitely Indirectly lost Bytes (subset of DB)

           •   RRBBkk : reachable Blocks

           •   PPBBkk : Possibly lost Blocks

           •   IIBBkk : Indirectly lost Blocks

           •   DDBBkk : Definitely lost Blocks

           The increase or decrease for all events above will also be output in the file to provide
           the delta (increase or decrease) between 2 successive leak searches. For example, iiRRBB is
           the increase of the RRBB event, ddPPBBkk is the decrease of PPBBkk event. The values for the
           increase and decrease events will be zero for the first leak search done.

           See ???  for a detailed explanation about execution trees.

       ----xxttrreeee--lleeaakk--ffiillee==<<ffiilleennaammee>> [[ddeeffaauulltt:: xxttlleeaakk..kkccgg..%%pp]]
           Specifies that Valgrind should produce the xtree leak report in the specified file. Any %%pp,
           %%qq or %%nn sequences appearing in the filename are expanded in exactly the same way as they
           are for ----lloogg--ffiillee. See the description of --log-file for details.

           See ???  for a detailed explanation about execution trees formats.

       ----uunnddeeff--vvaalluuee--eerrrroorrss==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           Controls whether Memcheck reports uses of undefined value errors. Set this to _n_o if you
           don't want to see undefined value errors. It also has the side effect of speeding up
           Memcheck somewhat. AddrCheck (removed in Valgrind 3.1.0) functioned like Memcheck with
           ----uunnddeeff--vvaalluuee--eerrrroorrss==nnoo.

       ----ttrraacckk--oorriiggiinnss==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Controls whether Memcheck tracks the origin of uninitialised values. By default, it does
           not, which means that although it can tell you that an uninitialised value is being used in
           a dangerous way, it cannot tell you where the uninitialised value came from. This often
           makes it difficult to track down the root problem.

           When set to _y_e_s, Memcheck keeps track of the origins of all uninitialised values. Then,
           when an uninitialised value error is reported, Memcheck will try to show the origin of the
           value. An origin can be one of the following four places: a heap block, a stack allocation,
           a client request, or miscellaneous other sources (eg, a call to _b_r_k).

           For uninitialised values originating from a heap block, Memcheck shows where the block was
           allocated. For uninitialised values originating from a stack allocation, Memcheck can tell
           you which function allocated the value, but no more than that -- typically it shows you the
           source location of the opening brace of the function. So you should carefully check that
           all of the function's local variables are initialised properly.

           Performance overhead: origin tracking is expensive. It halves Memcheck's speed and
           increases memory use by a minimum of 100MB, and possibly more. Nevertheless it can
           drastically reduce the effort required to identify the root cause of uninitialised value
           errors, and so is often a programmer productivity win, despite running more slowly.

           Accuracy: Memcheck tracks origins quite accurately. To avoid very large space and time
           overheads, some approximations are made. It is possible, although unlikely, that Memcheck
           will report an incorrect origin, or not be able to identify any origin.

           Note that the combination ----ttrraacckk--oorriiggiinnss==yyeess and ----uunnddeeff--vvaalluuee--eerrrroorrss==nnoo is nonsensical.
           Memcheck checks for and rejects this combination at startup.

       ----ppaarrttiiaall--llooaaddss--ookk==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           Controls how Memcheck handles 32-, 64-, 128- and 256-bit naturally aligned loads from
           addresses for which some bytes are addressable and others are not. When _y_e_s, such loads do
           not produce an address error. Instead, loaded bytes originating from illegal addresses are
           marked as uninitialised, and those corresponding to legal addresses are handled in the
           normal way.

           When _n_o, loads from partially invalid addresses are treated the same as loads from
           completely invalid addresses: an illegal-address error is issued, and the resulting bytes
           are marked as initialised.

           Note that code that behaves in this way is in violation of the ISO C/C++ standards, and
           should be considered broken. If at all possible, such code should be fixed.

       ----eexxppeennssiivvee--ddeeffiinneeddnneessss--cchheecckkss==<<nnoo||aauuttoo||yyeess>> [[ddeeffaauulltt:: aauuttoo]]
           Controls whether Memcheck should employ more precise but also more expensive (time
           consuming) instrumentation when checking the definedness of certain values. In particular,
           this affects the instrumentation of integer adds, subtracts and equality comparisons.

           Selecting ----eexxppeennssiivvee--ddeeffiinneeddnneessss--cchheecckkss==yyeess causes Memcheck to use the most accurate
           analysis possible. This minimises false error rates but can cause up to 30% performance
           degradation.

           Selecting ----eexxppeennssiivvee--ddeeffiinneeddnneessss--cchheecckkss==nnoo causes Memcheck to use the cheapest
           instrumentation possible. This maximises performance but will normally give an unusably
           high false error rate.

           The default setting, ----eexxppeennssiivvee--ddeeffiinneeddnneessss--cchheecckkss==aauuttoo, is strongly recommended. This
           causes Memcheck to use the minimum of expensive instrumentation needed to achieve the same
           false error rate as ----eexxppeennssiivvee--ddeeffiinneeddnneessss--cchheecckkss==yyeess. It also enables an
           instrumentation-time analysis pass which aims to further reduce the costs of accurate
           instrumentation. Overall, the performance loss is generally around 5% relative to
           ----eexxppeennssiivvee--ddeeffiinneeddnneessss--cchheecckkss==nnoo, although this is strongly workload dependent. Note that
           the exact instrumentation settings in this mode are architecture dependent.

       ----kkeeeepp--ssttaacckkttrraacceess==aalllloocc||ffrreeee||aalllloocc--aanndd--ffrreeee||aalllloocc--tthheenn--ffrreeee||nnoonnee [[ddeeffaauulltt:: aalllloocc--aanndd--ffrreeee]]
           Controls which stack trace(s) to keep for malloc'd and/or free'd blocks.

           With _a_l_l_o_c_-_t_h_e_n_-_f_r_e_e, a stack trace is recorded at allocation time, and is associated with
           the block. When the block is freed, a second stack trace is recorded, and this replaces the
           allocation stack trace. As a result, any "use after free" errors relating to this block can
           only show a stack trace for where the block was freed.

           With _a_l_l_o_c_-_a_n_d_-_f_r_e_e, both allocation and the deallocation stack traces for the block are
           stored. Hence a "use after free" error will show both, which may make the error easier to
           diagnose. Compared to _a_l_l_o_c_-_t_h_e_n_-_f_r_e_e, this setting slightly increases Valgrind's memory
           use as the block contains two references instead of one.

           With _a_l_l_o_c, only the allocation stack trace is recorded (and reported). With _f_r_e_e, only the
           deallocation stack trace is recorded (and reported). These values somewhat decrease
           Valgrind's memory and cpu usage. They can be useful depending on the error types you are
           searching for and the level of detail you need to analyse them. For example, if you are
           only interested in memory leak errors, it is sufficient to record the allocation stack
           traces.

           With _n_o_n_e, no stack traces are recorded for malloc and free operations. If your program
           allocates a lot of blocks and/or allocates/frees from many different stack traces, this can
           significantly decrease cpu and/or memory required. Of course, few details will be reported
           for errors related to heap blocks.

           Note that once a stack trace is recorded, Valgrind keeps the stack trace in memory even if
           it is not referenced by any block. Some programs (for example, recursive algorithms) can
           generate a huge number of stack traces. If Valgrind uses too much memory in such
           circumstances, you can reduce the memory required with the options _-_-_k_e_e_p_-_s_t_a_c_k_t_r_a_c_e_s
           and/or by using a smaller value for the option _-_-_n_u_m_-_c_a_l_l_e_r_s.

           If you want to use --xtree-memory=full memory profiling (see ???  ), then you cannot
           specify _-_-_k_e_e_p_-_s_t_a_c_k_t_r_a_c_e_s_=_f_r_e_e or _-_-_k_e_e_p_-_s_t_a_c_k_t_r_a_c_e_s_=_n_o_n_e.

       ----ffrreeeelliisstt--vvooll==<<nnuummbbeerr>> [[ddeeffaauulltt:: 2200000000000000]]
           When the client program releases memory using ffrreeee (in C) or delete (C++), that memory is
           not immediately made available for re-allocation. Instead, it is marked inaccessible and
           placed in a queue of freed blocks. The purpose is to defer as long as possible the point at
           which freed-up memory comes back into circulation. This increases the chance that Memcheck
           will be able to detect invalid accesses to blocks for some significant period of time after
           they have been freed.

           This option specifies the maximum total size, in bytes, of the blocks in the queue. The
           default value is twenty million bytes. Increasing this increases the total amount of memory
           used by Memcheck but may detect invalid uses of freed blocks which would otherwise go
           undetected.

       ----ffrreeeelliisstt--bbiigg--bblloocckkss==<<nnuummbbeerr>> [[ddeeffaauulltt:: 11000000000000]]
           When making blocks from the queue of freed blocks available for re-allocation, Memcheck
           will in priority re-circulate the blocks with a size greater or equal to
           ----ffrreeeelliisstt--bbiigg--bblloocckkss. This ensures that freeing big blocks (in particular freeing blocks
           bigger than ----ffrreeeelliisstt--vvooll) does not immediately lead to a re-circulation of all (or a lot
           of) the small blocks in the free list. In other words, this option increases the likelihood
           to discover dangling pointers for the "small" blocks, even when big blocks are freed.

           Setting a value of 0 means that all the blocks are re-circulated in a FIFO order.

       ----wwoorrkkaarroouunndd--ggcccc229966--bbuuggss==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           When enabled, assume that reads and writes some small distance below the stack pointer are
           due to bugs in GCC 2.96, and does not report them. The "small distance" is 256 bytes by
           default. Note that GCC 2.96 is the default compiler on some ancient Linux distributions
           (RedHat 7.X) and so you may need to use this option. Do not use it if you do not have to,
           as it can cause real errors to be overlooked. A better alternative is to use a more recent
           GCC in which this bug is fixed.

           You may also need to use this option when working with GCC 3.X or 4.X on 32-bit PowerPC
           Linux. This is because GCC generates code which occasionally accesses below the stack
           pointer, particularly for floating-point to/from integer conversions. This is in violation
           of the 32-bit PowerPC ELF specification, which makes no provision for locations below the
           stack pointer to be accessible.

           This option is deprecated as of version 3.12 and may be removed from future versions. You
           should instead use ----iiggnnoorree--rraannggee--bbeellooww--sspp to specify the exact range of offsets below the
           stack pointer that should be ignored. A suitable equivalent is
           ----iiggnnoorree--rraannggee--bbeellooww--sspp==11002244--11.

       ----iiggnnoorree--rraannggee--bbeellooww--sspp==<<nnuummbbeerr>>--<<nnuummbbeerr>>
           This is a more general replacement for the deprecated ----wwoorrkkaarroouunndd--ggcccc229966--bbuuggss option. When
           specified, it causes Memcheck not to report errors for accesses at the specified offsets
           below the stack pointer. The two offsets must be positive decimal numbers and -- somewhat
           counterintuitively -- the first one must be larger, in order to imply a non-wraparound
           address range to ignore. For example, to ignore 4 byte accesses at 8192 bytes below the
           stack pointer, use ----iiggnnoorree--rraannggee--bbeellooww--sspp==88119922--88118899. Only one range may be specified.

       ----sshhooww--mmiissmmaattcchheedd--ffrreeeess==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           When enabled, Memcheck checks that heap blocks are deallocated using a function that
           matches the allocating function. That is, it expects _f_r_e_e to be used to deallocate blocks
           allocated by _m_a_l_l_o_c, _d_e_l_e_t_e for blocks allocated by _n_e_w, and _d_e_l_e_t_e_[_] for blocks allocated
           by _n_e_w_[_]. If a mismatch is detected, an error is reported. This is in general important
           because in some environments, freeing with a non-matching function can cause crashes.

           There is however a scenario where such mismatches cannot be avoided. That is when the user
           provides implementations of _n_e_w/_n_e_w_[_] that call _m_a_l_l_o_c and of _d_e_l_e_t_e/_d_e_l_e_t_e_[_] that call
           _f_r_e_e, and these functions are asymmetrically inlined. For example, imagine that _d_e_l_e_t_e_[_] is
           inlined but _n_e_w_[_] is not. The result is that Memcheck "sees" all _d_e_l_e_t_e_[_] calls as direct
           calls to _f_r_e_e, even when the program source contains no mismatched calls.

           This causes a lot of confusing and irrelevant error reports.  _-_-_s_h_o_w_-_m_i_s_m_a_t_c_h_e_d_-_f_r_e_e_s_=_n_o
           disables these checks. It is not generally advisable to disable them, though, because you
           may miss real errors as a result.

       ----iiggnnoorree--rraannggeess==00xxPPPP--00xxQQQQ[[,,00xxRRRR--00xxSSSS]]
           Any ranges listed in this option (and multiple ranges can be specified, separated by
           commas) will be ignored by Memcheck's addressability checking.

       ----mmaalllloocc--ffiillll==<<hheexxnnuummbbeerr>>
           Fills blocks allocated by malloc, new, etc, but not by calloc, with the specified byte.
           This can be useful when trying to shake out obscure memory corruption problems. The
           allocated area is still regarded by Memcheck as undefined -- this option only affects its
           contents. Note that ----mmaalllloocc--ffiillll does not affect a block of memory when it is used as
           argument to client requests VALGRIND_MEMPOOL_ALLOC or VALGRIND_MALLOCLIKE_BLOCK.

       ----ffrreeee--ffiillll==<<hheexxnnuummbbeerr>>
           Fills blocks freed by free, delete, etc, with the specified byte value. This can be useful
           when trying to shake out obscure memory corruption problems. The freed area is still
           regarded by Memcheck as not valid for access -- this option only affects its contents. Note
           that ----ffrreeee--ffiillll does not affect a block of memory when it is used as argument to client
           requests VALGRIND_MEMPOOL_FREE or VALGRIND_FREELIKE_BLOCK.

CCAACCHHEEGGRRIINNDD OOPPTTIIOONNSS
       ----II11==<<ssiizzee>>,,<<aassssoocciiaattiivviittyy>>,,<<lliinnee ssiizzee>>
           Specify the size, associativity and line size of the level 1 instruction cache.

       ----DD11==<<ssiizzee>>,,<<aassssoocciiaattiivviittyy>>,,<<lliinnee ssiizzee>>
           Specify the size, associativity and line size of the level 1 data cache.

       ----LLLL==<<ssiizzee>>,,<<aassssoocciiaattiivviittyy>>,,<<lliinnee ssiizzee>>
           Specify the size, associativity and line size of the last-level cache.

       ----ccaacchhee--ssiimm==nnoo||yyeess [[yyeess]]
           Enables or disables collection of cache access and miss counts.

       ----bbrraanncchh--ssiimm==nnoo||yyeess [[nnoo]]
           Enables or disables collection of branch instruction and misprediction counts. By default
           this is disabled as it slows Cachegrind down by approximately 25%. Note that you cannot
           specify ----ccaacchhee--ssiimm==nnoo and ----bbrraanncchh--ssiimm==nnoo together, as that would leave Cachegrind with no
           information to collect.

       ----ccaacchheeggrriinndd--oouutt--ffiillee==<<ffiillee>>
           Write the profile data to file rather than to the default output file,
           cachegrind.out.<pid>. The %%pp and %%qq format specifiers can be used to embed the process ID
           and/or the contents of an environment variable in the name, as is the case for the core
           option ----lloogg--ffiillee.

CCAALLLLGGRRIINNDD OOPPTTIIOONNSS
       ----ccaallllggrriinndd--oouutt--ffiillee==<<ffiillee>>
           Write the profile data to file rather than to the default output file, callgrind.out.<pid>.
           The %%pp and %%qq format specifiers can be used to embed the process ID and/or the contents of
           an environment variable in the name, as is the case for the core option ----lloogg--ffiillee. When
           multiple dumps are made, the file name is modified further; see below.

       ----dduummpp--lliinnee==<<nnoo||yyeess>> [[ddeeffaauulltt:: yyeess]]
           This specifies that event counting should be performed at source line granularity. This
           allows source annotation for sources which are compiled with debug information (--gg).

       ----dduummpp--iinnssttrr==<<nnoo||yyeess>> [[ddeeffaauulltt:: nnoo]]
           This specifies that event counting should be performed at per-instruction granularity. This
           allows for assembly code annotation. Currently the results can only be displayed by
           KCachegrind.

       ----ccoommpprreessss--ssttrriinnggss==<<nnoo||yyeess>> [[ddeeffaauulltt:: yyeess]]
           This option influences the output format of the profile data. It specifies whether strings
           (file and function names) should be identified by numbers. This shrinks the file, but makes
           it more difficult for humans to read (which is not recommended in any case).

       ----ccoommpprreessss--ppooss==<<nnoo||yyeess>> [[ddeeffaauulltt:: yyeess]]
           This option influences the output format of the profile data. It specifies whether
           numerical positions are always specified as absolute values or are allowed to be relative
           to previous numbers. This shrinks the file size.

       ----ccoommbbiinnee--dduummppss==<<nnoo||yyeess>> [[ddeeffaauulltt:: nnoo]]
           When enabled, when multiple profile data parts are to be generated these parts are appended
           to the same output file. Not recommended.

       ----dduummpp--eevveerryy--bbbb==<<ccoouunntt>> [[ddeeffaauulltt:: 00,, nneevveerr]]
           Dump profile data every ccoouunntt basic blocks. Whether a dump is needed is only checked when
           Valgrind's internal scheduler is run. Therefore, the minimum setting useful is about
           100000. The count is a 64-bit value to make long dump periods possible.

       ----dduummpp--bbeeffoorree==<<ffuunnccttiioonn>>
           Dump when entering ffuunnccttiioonn.

       ----zzeerroo--bbeeffoorree==<<ffuunnccttiioonn>>
           Zero all costs when entering ffuunnccttiioonn.

       ----dduummpp--aafftteerr==<<ffuunnccttiioonn>>
           Dump when leaving ffuunnccttiioonn.

       ----iinnssttrr--aattssttaarrtt==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           Specify if you want Callgrind to start simulation and profiling from the beginning of the
           program. When set to no, Callgrind will not be able to collect any information, including
           calls, but it will have at most a slowdown of around 4, which is the minimum Valgrind
           overhead. Instrumentation can be interactively enabled via callgrind_control -i on.

           Note that the resulting call graph will most probably not contain mmaaiinn, but will contain
           all the functions executed after instrumentation was enabled. Instrumentation can also be
           programmatically enabled/disabled. See the Callgrind include file callgrind.h for the macro
           you have to use in your source code.

           For cache simulation, results will be less accurate when switching on instrumentation later
           in the program run, as the simulator starts with an empty cache at that moment. Switch on
           event collection later to cope with this error.

       ----ccoolllleecctt--aattssttaarrtt==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           Specify whether event collection is enabled at beginning of the profile run.

           To only look at parts of your program, you have two possibilities:

            1. Zero event counters before entering the program part you want to profile, and dump the
               event counters to a file after leaving that program part.

            2. Switch on/off collection state as needed to only see event counters happening while
               inside of the program part you want to profile.

           The second option can be used if the program part you want to profile is called many times.
           Option 1, i.e. creating a lot of dumps is not practical here.

           Collection state can be toggled at entry and exit of a given function with the option
           ----ttooggggllee--ccoolllleecctt. If you use this option, collection state should be disabled at the
           beginning. Note that the specification of ----ttooggggllee--ccoolllleecctt implicitly sets
           ----ccoolllleecctt--ssttaattee==nnoo.

           Collection state can be toggled also by inserting the client request
           CALLGRIND_TOGGLE_COLLECT ; at the needed code positions.

       ----ttooggggllee--ccoolllleecctt==<<ffuunnccttiioonn>>
           Toggle collection on entry/exit of ffuunnccttiioonn.

       ----ccoolllleecctt--jjuummppss==<<nnoo||yyeess>> [[ddeeffaauulltt:: nnoo]]
           This specifies whether information for (conditional) jumps should be collected. As above,
           callgrind_annotate currently is not able to show you the data. You have to use KCachegrind
           to get jump arrows in the annotated code.

       ----ccoolllleecctt--ssyyssttiimmee==<<nnoo||yyeess>> [[ddeeffaauulltt:: nnoo]]
           This specifies whether information for system call times should be collected.

       ----ccoolllleecctt--bbuuss==<<nnoo||yyeess>> [[ddeeffaauulltt:: nnoo]]
           This specifies whether the number of global bus events executed should be collected. The
           event type "Ge" is used for these events.

       ----ccaacchhee--ssiimm==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Specify if you want to do full cache simulation. By default, only instruction read accesses
           will be counted ("Ir"). With cache simulation, further event counters are enabled: Cache
           misses on instruction reads ("I1mr"/"ILmr"), data read accesses ("Dr") and related cache
           misses ("D1mr"/"DLmr"), data write accesses ("Dw") and related cache misses
           ("D1mw"/"DLmw"). For more information, see Cachegrind: a cache and branch-prediction
           profiler.

       ----bbrraanncchh--ssiimm==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Specify if you want to do branch prediction simulation. Further event counters are enabled:
           Number of executed conditional branches and related predictor misses ("Bc"/"Bcm"), executed
           indirect jumps and related misses of the jump address predictor ("Bi"/"Bim").

HHEELLGGRRIINNDD OOPPTTIIOONNSS
       ----ffrreeee--iiss--wwrriittee==nnoo||yyeess [[ddeeffaauulltt:: nnoo]]
           When enabled (not the default), Helgrind treats freeing of heap memory as if the memory was
           written immediately before the free. This exposes races where memory is referenced by one
           thread, and freed by another, but there is no observable synchronisation event to ensure
           that the reference happens before the free.

           This functionality is new in Valgrind 3.7.0, and is regarded as experimental. It is not
           enabled by default because its interaction with custom memory allocators is not well
           understood at present. User feedback is welcomed.

       ----ttrraacckk--lloocckkoorrddeerrss==nnoo||yyeess [[ddeeffaauulltt:: yyeess]]
           When enabled (the default), Helgrind performs lock order consistency checking. For some
           buggy programs, the large number of lock order errors reported can become annoying,
           particularly if you're only interested in race errors. You may therefore find it helpful to
           disable lock order checking.

       ----hhiissttoorryy--lleevveell==nnoonnee||aapppprrooxx||ffuullll [[ddeeffaauulltt:: ffuullll]]
           ----hhiissttoorryy--lleevveell==ffuullll (the default) causes Helgrind collects enough information about "old"
           accesses that it can produce two stack traces in a race report -- both the stack trace for
           the current access, and the trace for the older, conflicting access. To limit memory usage,
           "old" accesses stack traces are limited to a maximum of 8 entries, even if ----nnuumm--ccaalllleerrss
           value is bigger.

           Collecting such information is expensive in both speed and memory, particularly for
           programs that do many inter-thread synchronisation events (locks, unlocks, etc). Without
           such information, it is more difficult to track down the root causes of races. Nonetheless,
           you may not need it in situations where you just want to check for the presence or absence
           of races, for example, when doing regression testing of a previously race-free program.

           ----hhiissttoorryy--lleevveell==nnoonnee is the opposite extreme. It causes Helgrind not to collect any
           information about previous accesses. This can be dramatically faster than
           ----hhiissttoorryy--lleevveell==ffuullll.

           ----hhiissttoorryy--lleevveell==aapppprrooxx provides a compromise between these two extremes. It causes Helgrind
           to show a full trace for the later access, and approximate information regarding the
           earlier access. This approximate information consists of two stacks, and the earlier access
           is guaranteed to have occurred somewhere between program points denoted by the two stacks.
           This is not as useful as showing the exact stack for the previous access (as
           ----hhiissttoorryy--lleevveell==ffuullll does), but it is better than nothing, and it is almost as fast as
           ----hhiissttoorryy--lleevveell==nnoonnee.

       ----ddeellttaa--ssttaacckkttrraaccee==nnoo||yyeess [[ddeeffaauulltt:: yyeess oonn lliinnuuxx aammdd6644//xx8866]]
           This flag only has any effect at ----hhiissttoorryy--lleevveell==ffuullll.

           ----ddeellttaa--ssttaacckkttrraaccee configures the way Helgrind captures the stacktraces for the option
           ----hhiissttoorryy--lleevveell==ffuullll. Such a stacktrace is typically needed each time a new piece of memory
           is read or written in a basic block of instructions.

           ----ddeellttaa--ssttaacckkttrraaccee==nnoo causes Helgrind to compute a full history stacktrace from the unwind
           info each time a stacktrace is needed.

           ----ddeellttaa--ssttaacckkttrraaccee==yyeess indicates to Helgrind to derive a new stacktrace from the previous
           stacktrace, as long as there was no call instruction, no return instruction, or any other
           instruction changing the call stack since the previous stacktrace was captured. If no such
           instruction was executed, the new stacktrace can be derived from the previous stacktrace by
           just changing the top frame to the current program counter. This option can speed up
           Helgrind by 25% when using ----hhiissttoorryy--lleevveell==ffuullll.

           The following aspects have to be considered when using ----ddeellttaa--ssttaacckkttrraaccee==yyeess :

           •   In some cases (for example in a function prologue), the
                           valgrind unwinder might not properly unwind the stack, due to some
                           limitations and/or due to wrong unwind info. When using
                           --delta-stacktrace=yes, the wrong stack trace captured in the
                           function prologue will be kept till the next call or return.
                         .RE

               •   On the other hand, --delta-stacktrace=yes sometimes helps to
                               obtain a correct stacktrace, for example when the unwind info allows
                               a correct stacktrace to be done in the beginning of the sequence,
                               but not later on in the instruction sequence..RE

                   •   Determining which instructions are changing the callstack is
                                   partially based on platform dependent heuristics, which have to be
                                   tuned/validated specifically for the platform. Also, unwinding in a
                                   function prologue must be good enough to allow using
                                   --delta-stacktrace=yes. Currently, the option
                       --delta-stacktrace=yes
                                   has been reasonably validated only on linux x86 32 bits and linux
                                   amd64 64 bits. For more details about how to validate
                                   --delta-stacktrace=yes, see debug option --hg-sanity-flags and the
                                   function check_cached_rcec_ok in libhb_core.c..RE

                   ----ccoonnfflliicctt--ccaacchhee--ssiizzee==NN [[ddeeffaauulltt:: 11000000000000]]
                       This flag only has any effect at ----hhiissttoorryy--lleevveell==ffuullll.

                       Information about "old" conflicting accesses is stored in a cache of limited
                       size, with LRU-style management. This is necessary because it isn't practical
                       to store a stack trace for every single memory access made by the program.
                       Historical information on not recently accessed locations is periodically
                       discarded, to free up space in the cache.

                       This option controls the size of the cache, in terms of the number of different
                       memory addresses for which conflicting access information is stored. If you
                       find that Helgrind is showing race errors with only one stack instead of the
                       expected two stacks, try increasing this value.

                       The minimum value is 10,000 and the maximum is 30,000,000 (thirty times the
                       default value). Increasing the value by 1 increases Helgrind's memory
                       requirement by very roughly 100 bytes, so the maximum value will easily eat up
                       three extra gigabytes or so of memory.

                   ----cchheecckk--ssttaacckk--rreeffss==nnoo||yyeess [[ddeeffaauulltt:: yyeess]]
                       By default Helgrind checks all data memory accesses made by your program. This
                       flag enables you to skip checking for accesses to thread stacks (local
                       variables). This can improve performance, but comes at the cost of missing
                       races on stack-allocated data.

                   ----iiggnnoorree--tthhrreeaadd--ccrreeaattiioonn==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
                       Controls whether all activities during thread creation should be ignored. By
                       default enabled only on Solaris. Solaris provides higher throughput,
                       parallelism and scalability than other operating systems, at the cost of more
                       fine-grained locking activity. This means for example that when a thread is
                       created under glibc, just one big lock is used for all thread setup. Solaris
                       libc uses several fine-grained locks and the creator thread resumes its
                       activities as soon as possible, leaving for example stack and TLS setup
                       sequence to the created thread. This situation confuses Helgrind as it assumes
                       there is some false ordering in place between creator and created thread; and
                       therefore many types of race conditions in the application would not be
                       reported. To prevent such false ordering, this command line option is set to
                       yes by default on Solaris. All activity (loads, stores, client requests) is
                       therefore ignored during:

                       •   pthread_create() call in the creator thread

                       •   thread creation phase (stack and TLS setup) in the created thread

                       Also new memory allocated during thread creation is untracked, that is race
                       reporting is suppressed there. DRD does the same thing implicitly. This is
                       necessary because Solaris libc caches many objects and reuses them for
                       different threads and that confuses Helgrind.

DDRRDD OOPPTTIIOONNSS
       ----cchheecckk--ssttaacckk--vvaarr==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Controls whether DRD detects data races on stack variables. Verifying stack variables is
           disabled by default because most programs do not share stack variables over threads.

       ----eexxcclluussiivvee--tthhrreesshhoolldd==<<nn>> [[ddeeffaauulltt:: ooffff]]
           Print an error message if any mutex or writer lock has been held longer than the time
           specified in milliseconds. This option enables the detection of lock contention.

       ----jjooiinn--lliisstt--vvooll==<<nn>> [[ddeeffaauulltt:: 1100]]
           Data races that occur between a statement at the end of one thread and another thread can
           be missed if memory access information is discarded immediately after a thread has been
           joined. This option allows one to specify for how many joined threads memory access
           information should be retained.

        ----ffiirrsstt--rraaccee--oonnllyy==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Whether to report only the first data race that has been detected on a memory location or
           all data races that have been detected on a memory location.

        ----ffrreeee--iiss--wwrriittee==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Whether to report races between accessing memory and freeing memory. Enabling this option
           may cause DRD to run slightly slower. Notes:

           •   Don't enable this option when using custom memory allocators that use the
               VG_USERREQ__MALLOCLIKE_BLOCK and VG_USERREQ__FREELIKE_BLOCK because that would result
               in false positives.

           •   Don't enable this option when using reference-counted objects because that will result
               in false positives, even when that code has been annotated properly with
               ANNOTATE_HAPPENS_BEFORE and ANNOTATE_HAPPENS_AFTER. See e.g. the output of the
               following command for an example: valgrind --tool=drd --free-is-write=yes
               drd/tests/annotate_smart_pointer.

        ----rreeppoorrtt--ssiiggnnaall--uunnlloocckkeedd==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           Whether to report calls to pptthhrreeaadd__ccoonndd__ssiiggnnaall and pptthhrreeaadd__ccoonndd__bbrrooaaddccaasstt where the mutex
           associated with the signal through pptthhrreeaadd__ccoonndd__wwaaiitt or pptthhrreeaadd__ccoonndd__ttiimmeedd__wwaaiittis not
           locked at the time the signal is sent. Sending a signal without holding a lock on the
           associated mutex is a common programming error which can cause subtle race conditions and
           unpredictable behavior. There exist some uncommon synchronization patterns however where it
           is safe to send a signal without holding a lock on the associated mutex.

       ----sseeggmmeenntt--mmeerrggiinngg==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           Controls segment merging. Segment merging is an algorithm to limit memory usage of the data
           race detection algorithm. Disabling segment merging may improve the accuracy of the
           so-called 'other segments' displayed in race reports but can also trigger an out of memory
           error.

       ----sseeggmmeenntt--mmeerrggiinngg--iinntteerrvvaall==<<nn>> [[ddeeffaauulltt:: 1100]]
           Perform segment merging only after the specified number of new segments have been created.
           This is an advanced configuration option that allows one to choose whether to minimize
           DRD's memory usage by choosing a low value or to let DRD run faster by choosing a slightly
           higher value. The optimal value for this parameter depends on the program being analyzed.
           The default value works well for most programs.

       ----sshhaarreedd--tthhrreesshhoolldd==<<nn>> [[ddeeffaauulltt:: ooffff]]
           Print an error message if a reader lock has been held longer than the specified time (in
           milliseconds). This option enables the detection of lock contention.

       ----sshhooww--ccoonnffll--sseegg==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           Show conflicting segments in race reports. Since this information can help to find the
           cause of a data race, this option is enabled by default. Disabling this option makes the
           output of DRD more compact.

       ----sshhooww--ssttaacckk--uussaaggee==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Print stack usage at thread exit time. When a program creates a large number of threads it
           becomes important to limit the amount of virtual memory allocated for thread stacks. This
           option makes it possible to observe how much stack memory has been used by each thread of
           the client program. Note: the DRD tool itself allocates some temporary data on the client
           thread stack. The space necessary for this temporary data must be allocated by the client
           program when it allocates stack memory, but is not included in stack usage reported by DRD.

       ----iiggnnoorree--tthhrreeaadd--ccrreeaattiioonn==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Controls whether all activities during thread creation should be ignored. By default
           enabled only on Solaris. Solaris provides higher throughput, parallelism and scalability
           than other operating systems, at the cost of more fine-grained locking activity. This means
           for example that when a thread is created under glibc, just one big lock is used for all
           thread setup. Solaris libc uses several fine-grained locks and the creator thread resumes
           its activities as soon as possible, leaving for example stack and TLS setup sequence to the
           created thread. This situation confuses DRD as it assumes there is some false ordering in
           place between creator and created thread; and therefore many types of race conditions in
           the application would not be reported. To prevent such false ordering, this command line
           option is set to yes by default on Solaris. All activity (loads, stores, client requests)
           is therefore ignored during:

           •   pthread_create() call in the creator thread

           •   thread creation phase (stack and TLS setup) in the created thread

       ----ttrraaccee--aaddddrr==<<aaddddrreessss>> [[ddeeffaauulltt:: nnoonnee]]
           Trace all load and store activity for the specified address. This option may be specified
           more than once.

       ----ppttrraaccee--aaddddrr==<<aaddddrreessss>> [[ddeeffaauulltt:: nnoonnee]]
           Trace all load and store activity for the specified address and keep doing that even after
           the memory at that address has been freed and reallocated.

       ----ttrraaccee--aalllloocc==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Trace all memory allocations and deallocations. May produce a huge amount of output.

       ----ttrraaccee--bbaarrrriieerr==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Trace all barrier activity.

       ----ttrraaccee--ccoonndd==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Trace all condition variable activity.

       ----ttrraaccee--ffoorrkk--jjooiinn==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Trace all thread creation and all thread termination events.

       ----ttrraaccee--hhbb==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Trace execution of the ANNOTATE_HAPPENS_BEFORE(), ANNOTATE_HAPPENS_AFTER() and
           ANNOTATE_HAPPENS_DONE() client requests.

       ----ttrraaccee--mmuutteexx==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Trace all mutex activity.

       ----ttrraaccee--rrwwlloocckk==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Trace all reader-writer lock activity.

       ----ttrraaccee--sseemmaapphhoorree==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Trace all semaphore activity.

MMAASSSSIIFF OOPPTTIIOONNSS
       ----hheeaapp==<<yyeess||nnoo>> [[ddeeffaauulltt:: yyeess]]
           Specifies whether heap profiling should be done.

       ----hheeaapp--aaddmmiinn==<<ssiizzee>> [[ddeeffaauulltt:: 88]]
           If heap profiling is enabled, gives the number of administrative bytes per block to use.
           This should be an estimate of the average, since it may vary. For example, the allocator
           used by glibc on Linux requires somewhere between 4 to 15 bytes per block, depending on
           various factors. That allocator also requires admin space for freed blocks, but Massif
           cannot account for this.

       ----ssttaacckkss==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Specifies whether stack profiling should be done. This option slows Massif down greatly,
           and so is off by default. Note that Massif assumes that the main stack has size zero at
           start-up. This is not true, but doing otherwise accurately is difficult. Furthermore,
           starting at zero better indicates the size of the part of the main stack that a user
           program actually has control over.

       ----ppaaggeess--aass--hheeaapp==<<yyeess||nnoo>> [[ddeeffaauulltt:: nnoo]]
           Tells Massif to profile memory at the page level rather than at the malloc'd block level.
           See above for details.

       ----ddeepptthh==<<nnuummbbeerr>> [[ddeeffaauulltt:: 3300]]
           Maximum depth of the allocation trees recorded for detailed snapshots. Increasing it will
           make Massif run somewhat more slowly, use more memory, and produce bigger output files.

       ----aalllloocc--ffnn==<<nnaammee>>
           Functions specified with this option will be treated as though they were a heap allocation
           function such as mmaalllloocc. This is useful for functions that are wrappers to mmaalllloocc or nneeww,
           which can fill up the allocation trees with uninteresting information. This option can be
           specified multiple times on the command line, to name multiple functions.

           Note that the named function will only be treated this way if it is the top entry in a
           stack trace, or just below another function treated this way. For example, if you have a
           function mmaalllloocc11 that wraps mmaalllloocc, and mmaalllloocc22 that wraps mmaalllloocc11, just specifying
           ----aalllloocc--ffnn==mmaalllloocc22 will have no effect. You need to specify ----aalllloocc--ffnn==mmaalllloocc11 as well.
           This is a little inconvenient, but the reason is that checking for allocation functions is
           slow, and it saves a lot of time if Massif can stop looking through the stack trace entries
           as soon as it finds one that doesn't match rather than having to continue through all the
           entries.

           Note that C++ names are demangled. Note also that overloaded C++ names must be written in
           full. Single quotes may be necessary to prevent the shell from breaking them up. For
           example:

               --alloc-fn='operator new(unsigned, std::nothrow_t const&)'

       ----iiggnnoorree--ffnn==<<nnaammee>>
           Any direct heap allocation (i.e. a call to mmaalllloocc, nneeww, etc, or a call to a function named
           by an ----aalllloocc--ffnn option) that occurs in a function specified by this option will be
           ignored. This is mostly useful for testing purposes. This option can be specified multiple
           times on the command line, to name multiple functions.

           Any rreeaalllloocc of an ignored block will also be ignored, even if the rreeaalllloocc call does not
           occur in an ignored function. This avoids the possibility of negative heap sizes if ignored
           blocks are shrunk with rreeaalllloocc.

           The rules for writing C++ function names are the same as for ----aalllloocc--ffnn above.

       ----tthhrreesshhoolldd==<<mm..nn>> [[ddeeffaauulltt:: 11..00]]
           The significance threshold for heap allocations, as a percentage of total memory size.
           Allocation tree entries that account for less than this will be aggregated. Note that this
           should be specified in tandem with ms_print's option of the same name.

       ----ppeeaakk--iinnaaccccuurraaccyy==<<mm..nn>> [[ddeeffaauulltt:: 11..00]]
           Massif does not necessarily record the actual global memory allocation peak; by default it
           records a peak only when the global memory allocation size exceeds the previous peak by at
           least 1.0%. This is because there can be many local allocation peaks along the way, and
           doing a detailed snapshot for every one would be expensive and wasteful, as all but one of
           them will be later discarded. This inaccuracy can be changed (even to 0.0%) via this
           option, but Massif will run drastically slower as the number approaches zero.

       ----ttiimmee--uunniitt==<<ii||mmss||BB>> [[ddeeffaauulltt:: ii]]
           The time unit used for the profiling. There are three possibilities: instructions executed
           (i), which is good for most cases; real (wallclock) time (ms, i.e. milliseconds), which is
           sometimes useful; and bytes allocated/deallocated on the heap and/or stack (B), which is
           useful for very short-run programs, and for testing purposes, because it is the most
           reproducible across different machines.

       ----ddeettaaiilleedd--ffrreeqq==<<nn>> [[ddeeffaauulltt:: 1100]]
           Frequency of detailed snapshots. With ----ddeettaaiilleedd--ffrreeqq==11, every snapshot is detailed.

       ----mmaaxx--ssnnaappsshhoottss==<<nn>> [[ddeeffaauulltt:: 110000]]
           The maximum number of snapshots recorded. If set to N, for all programs except very
           short-running ones, the final number of snapshots will be between N/2 and N.

       ----mmaassssiiff--oouutt--ffiillee==<<ffiillee>> [[ddeeffaauulltt:: mmaassssiiff..oouutt..%%pp]]
           Write the profile data to file rather than to the default output file, massif.out.<pid>.
           The %%pp and %%qq format specifiers can be used to embed the process ID and/or the contents of
           an environment variable in the name, as is the case for the core option ----lloogg--ffiillee.

SSGGCCHHEECCKK OOPPTTIIOONNSS
       There are no SGCheck-specific command-line options at present.

BBBBVV OOPPTTIIOONNSS
       ----bbbb--oouutt--ffiillee==<<nnaammee>> [[ddeeffaauulltt:: bbbb..oouutt..%%pp]]
           This option selects the name of the basic block vector file. The %%pp and %%qq format
           specifiers can be used to embed the process ID and/or the contents of an environment
           variable in the name, as is the case for the core option ----lloogg--ffiillee.

       ----ppcc--oouutt--ffiillee==<<nnaammee>> [[ddeeffaauulltt:: ppcc..oouutt..%%pp]]
           This option selects the name of the PC file. This file holds program counter addresses and
           function name info for the various basic blocks. This can be used in conjunction with the
           basic block vector file to fast-forward via function names instead of just instruction
           counts. The %%pp and %%qq format specifiers can be used to embed the process ID and/or the
           contents of an environment variable in the name, as is the case for the core option ----lloogg--
           ffiillee.

       ----iinntteerrvvaall--ssiizzee==<<nnuummbbeerr>> [[ddeeffaauulltt:: 110000000000000000]]
           This option selects the size of the interval to use. The default is 100 million
           instructions, which is a commonly used value. Other sizes can be used; smaller intervals
           can help programs with finer-grained phases. However smaller interval size can lead to
           accuracy issues due to warm-up effects (When fast-forwarding the various architectural
           features will be un-initialized, and it will take some number of instructions before they
           "warm up" to the state a full simulation would be at without the fast-forwarding. Large
           interval sizes tend to mitigate this.)

       ----iinnssttrr--ccoouunntt--oonnllyy [[ddeeffaauulltt:: nnoo]]
           This option tells the tool to only display instruction count totals, and to not generate
           the actual basic block vector file. This is useful for debugging, and for gathering
           instruction count info without generating the large basic block vector files.

LLAACCKKEEYY OOPPTTIIOONNSS
       ----bbaassiicc--ccoouunnttss==<<nnoo||yyeess>> [[ddeeffaauulltt:: yyeess]]
           When enabled, Lackey prints the following statistics and information about the execution of
           the client program:

            1. The number of calls to the function specified by the ----ffnnnnaammee option (the default is
               main). If the program has had its symbols stripped, the count will always be zero.

            2. The number of conditional branches encountered and the number and proportion of those
               taken.

            3. The number of superblocks entered and completed by the program. Note that due to
               optimisations done by the JIT, this is not at all an accurate value.

            4. The number of guest (x86, amd64, ppc, etc.) instructions and IR statements executed. IR
               is Valgrind's RISC-like intermediate representation via which all instrumentation is
               done.

            5. Ratios between some of these counts.

            6. The exit code of the client program.

       ----ddeettaaiilleedd--ccoouunnttss==<<nnoo||yyeess>> [[ddeeffaauulltt:: nnoo]]
           When enabled, Lackey prints a table containing counts of loads, stores and ALU operations,
           differentiated by their IR types. The IR types are identified by their IR name ("I1", "I8",
           ... "I128", "F32", "F64", and "V128").

       ----ttrraaccee--mmeemm==<<nnoo||yyeess>> [[ddeeffaauulltt:: nnoo]]
           When enabled, Lackey prints the size and address of almost every memory access made by the
           program. See the comments at the top of the file lackey/lk_main.c for details about the
           output format, how it works, and inaccuracies in the address trace. Note that this option
           produces immense amounts of output.

       ----ttrraaccee--ssuuppeerrbblloocckkss==<<nnoo||yyeess>> [[ddeeffaauulltt:: nnoo]]
           When enabled, Lackey prints out the address of every superblock (a single entry, multiple
           exit, linear chunk of code) executed by the program. This is primarily of interest to
           Valgrind developers. See the comments at the top of the file lackey/lk_main.c for details
           about the output format. Note that this option produces large amounts of output.

       ----ffnnnnaammee==<<nnaammee>> [[ddeeffaauulltt:: mmaaiinn]]
           Changes the function for which calls are counted when ----bbaassiicc--ccoouunnttss==yyeess is specified.

SSEEEE AALLSSOO
       cg_annotate(1), callgrind_annotate(1), callgrind_control(1), ms_print(1),
       $INSTALL/share/doc/valgrind/html/index.html or http://www.valgrind.org/docs/manual/index.html,
       DDeebbuuggggiinngg yyoouurr pprrooggrraamm uussiinngg VVaallggrriinndd''ss ggddbbsseerrvveerr aanndd GGDDBB[1] vvggddbb[2], VVaallggrriinndd mmoonniittoorr
       ccoommmmaannddss[3], TThhee CCoommmmeennttaarryy[4], SScchheedduulliinngg aanndd MMuullttii--TThhrreeaadd PPeerrffoorrmmaannccee[5], CCaacchheeggrriinndd:: aa ccaacchhee
       aanndd bbrraanncchh--pprreeddiiccttiioonn pprrooffiilleerr[6].

AAUUTTHHOORR
       See the AUTHORS file in the valgrind distribution for a comprehensive list of authors.

       This manpage was written by Andres Roldan <aroldan@debian.org> and the Valgrind developers.

NNOOTTEESS
        1. Debugging your program using Valgrind's gdbserver and GDB
           http://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.gdbserver

        2. vgdb
           http://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.vgdb

        3. Valgrind monitor commands
           http://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.valgrind-monitor-commands

        4. The Commentary
           http://www.valgrind.org/docs/manual/manual-core.html#manual-core.comment

        5. Scheduling and Multi-Thread Performance
           http://www.valgrind.org/docs/manual/manual-core.html#manual-core.pthreads_perf_sched

        6. Cachegrind: a cache and branch-prediction profiler
           http://www.valgrind.org/docs/manual/cg-manual.html

Release 3.15.0                                08/20/2020                                   VALGRIND(1)
